Software used in this development:
o Qt (LGPL)
o Oxygen theme icons (LGPL)
o SQLite (public domain)
o FANN (LGPL)
o NCBI Toolkit + (public domain)


[29 Jan 2010 :: 9:10 am, Luke]
-- A couple weeks ago, I decided to use SQLite (v3) as the application file format. This greatly simplified the issue
   of input/output of data files. My original intent was to only use the SQLite database when loading and saving user
   files. Since today, I am debating this idea for various reasons:

   o Memory issues with large projects: In the above approach, everything is stored in memory until a document is closed.
     This could be a potentially nasty memory hog - especially with big projects containing several thousand sequences
     and other related data.
   o In-memory storage and retrieval: With every new derived data construct (e.g. pfam domains or secondary structure)
     we have to produce a class for this data object and a mechanism for storing and easily linking these to N distinct
     entities.
   o Users will only be working with a relatively small slice of the data at any given time. Thus, there is no need to
     maintain the entire project data in memory at once.

   Using a SQLite database completely sidesteps these issues (along with providing the benefits of a SQL-based data file).
   Data can be loaded into memory on-demand for those processes that need ultra fast access or specialized controller
   classes (e.g. MSA editing) and then saved back to the database once completed. On the other hand, simply viewing the
   annotation data and/or other data fields in a TableView does not require an in-memory approach.

   With regard to storage/retrieval, SQLite is well-suited to this task. It can easily provide internal identifiers for
   each piece of data and these in turn be used as markers throughout the program and widgets.

   In the worst case, could still use SQLite using the :in-memory construct for achieving this functionality without any
   associated file.

-- Is there sufficient rationale/support for using SQLite as the data file format?

   o http://www.sqlite.org/whentouse.html :: SQLite themselves declare this to be an optimal use
   o http://www.sqlite.org/famous.html :: Industry examples

-- SQLite rules:

   o Primary key columns do not necessarily auto increment. Rather, they take the max(id)+1. If auto_increment is
     set, then this property always increases.
   o Use single quotes for string literals and double quotes for table/column names
   o Only ALTER TABLE commands: rename table and add column; have to create temporary table, create new table, copy
     data over and then drop old table. Ugh.
   o Foreign keys supported in SQLite from 3.6.19 or greater. They are disabled by default and must be turned on for
     every database session (http://www.sqlite.org/foreignkeys.html):

     > pragma foreign_keys = ON;

   o Need to vacuum regularly to free up space. This may take a bit of time though.
   o Need to version the schema - which should correlate nicely the version of the file format

-- Internal ids of each row **must not be used for user identification purposes** as these can change as needed.



custom fields prefixed with data- (as in HTML5)


[3 Feb 2010]
 -- FINALLY!! Got the swine AbstractItemModel / TreeView / SortFilterProxyModel dealio working!

    >> Important factors when dealing with QSortFilterProxyModel:
       o Inside filterAcceptsRow must ensure that both the new root index and all relevant descendant children

-- To display icons with QAbstractItemModel, simply return the appropriate icon from the reimplmented data() function

-- Store tree in database using Modified Pre-order Tree Traversal

-- We rely on the sqlite database being consistent; however, by making it a sqlite file, it becomes possible for users
   to easily corrupt and place the datafile into an inconsistent state. Will need some mechanism for check the data
   integrity after loading.

-- QFile contains the methods for copying/renaming/removing files
-- Use QTemporaryFile for temporary files

-- Flow control:

   >> Version 1.0
      o On startup, create new empty document. This will consist of a sqlite database stored in temporary file
      o Upon saving a temporary document file, ask the user for a filename to save it as first. All database requests
        will actually get saved to the temporary file; however, this will be destroyed unless it is saved to a
        user-specified permanent location.
      o A new document will automatically have a skeletal directory structure as follows:

        Root
          Project
            Alignments
              DNA
              Protein
              RNA
            Primers
            Sequences
              DNA
              Protein
              RNA

      o The root node is invisible and cannot be edited
      o The above skeleton may be rearranged, edited, tweaked as desired by the user except for the root and project
        nodes. The only operation that may be done for a project is to delete and/or rename it
      o Confirm project removal with a messagebox
      o A project may not be undeleted once it has been deleted
      o New projects may be created by selecting File | New project...
      o Each new project has the above skeleton

      o User may import FASTA sequences and/or alignments
      o After user has imported a file, display dialog with the imported sequences:
        - Displayed with tableview: (checkbox to import, sequence header, sequence)
        - Guessed format in combobox
        - Number of parsed sequences displayed, number to import (checked=true) also displayed
        - Treeview asking user where to save sequences to. Controls for creating new folders/locations
          :: By default, place under the currently active project directly under the Project node
        - Cancel / Import button

        :: How to deal with alignment which has both sequences and alignment node?

      o Upon clicking the import button
        :: Save sequences to the appropriate tables in the database
        :: Create the corresponding nodes inside the treeview model with the beginInsertRows/endInsertRows method
        :: Save tree to database
        :: Q? How to update the corresponding rightside treeview as necessary? I suppose add the corresponding nodes
           to the active model (right treeview) at the same time. Should only have to do the active model on the
           right, because there will be no other views that will see this data...as of right now. Catch the signal in
           the right view and grab the column data as desired.

        :: Or an alternate approach, if the imported sequences are located within the right treeview's root index, then
           simply save the current selection, add the nodes to the active model, reset, restore selection. **Preferred**

      o Create a model class for each of the different types of data/nodes that may be present. ProxyModels will be
        layered on as needed. The initial set of models are:

        1. Base tree model for wrapping the TreeNode object interface
           -> Proxy Model for displaying only root | project | group nodes in folder view (left hand pane)
        2. [Proxy model] Simple view for displaying and editing any and all items
        3. 3 Seq-based models. Each of these will act as a filter to only display the appropriate seq type and the
           relevant annotation columns. All subseqs
        4. 3 subseq-based models - ditto for this but with respect to subseqs; does not show subseqs beneath alignment
        5. 3 alignment based models which function similarly to subseq models, but only display for alignments and the
           corresponding subseqs beneath them
        6. Primer model


        ** Group nodes / folders will have a column that spans all columns
        **

   >> Version 1.1
   o On startup, provide for opening last document or creating new document
   o Default project skeleton may be defined by user in Tools | Options...
   o Data integrity check on loading document files
   o Option to specify path for temporary database files (e.g. that are automatically created for new AlignShop documents)
   o Deal with orphan nodes!

   >> Version 2.0
   o Integration with BLAST/PSI-BLAST and BLAST databases
   o Password-protected / encrypted SQLite files


-- Currently, the database will be stored on the file system rather than being stored in memory; however, if
   the files are small enough this should not be a problem to keep in memory. We'll just see how it grows over time.
   For information on loading/saving databases to/from memory, check out this link:

   http://www.sqlite.org/backup.html

   Although I don't see how to utilize this with Qt. Perhaps, linking in SQLite by itself or if it is compiled directly
   with Qt, might could call these functions directly.

[4 Feb 2010]
 -- While sqlite supports foreign keys it is possible to turn them off and/or not use them. Thus, it is possible for
    the database to enter an inconsistent state:

    create table parents (id integer primary key autoincrement);
    create table children (parent_id integer not null foreign key(parent_id) references parents(id));

    pragma foreign_keys = off;

    insert into parents values (10);
    insert into children values (30);

    pragma foreign keys = on;

    >> It is not known without running various queries that rows in children do not correspond to some rows in the
       parents table.

    Because we are using SQLite databases as the AlignShop document format, it is very easy to corrupt the file data.
    Users could easily turn off foreign key support and then wreak havoc. I suppose this is a valid concern.

    Another potential issue is that users may create additional tables of their own that link back to AlignShop specific
    tables and restrict normal operations (e.g. not able to delete a record that user has linked with FK on delete restrict).

    Possible solutions:
    >> Do database check against expected database tables and if there are extra tables outside this
       remove any foreign key constraints.
    >> Just inform the user that any kind of hacking of this nature indicates they know what they are doing and should
       be willing to deal with the consequences. Explain that all FK should have on delete cascade. Provide option for
       removing extra tables...?

-- Store version information about data file inside the database itself!

-- How to install the executable after it is finished? InstallJammer (installjammer.com)

-- Need to think of a way to name the models.

   o TreeModel / TreeNode - way to broad and non-specific. Also may present confusion when phylogenetic trees are added
     to the mix
   o DataTreeModel / DataTreeNode - still to vague and non-specific. Data could refer to anything
   o AsTreeModel / AsTreeNode - for AlignShop Tree model and AlignShop tree node. Probably would work although the As
     abbreviation is somehwat non-descript
   o Model / Node - too simple; a Node could refer to anything
   o -->> [Selected] AdocTreeModel / AdocTreeNode - again using abbreviation for AlignShop, but so-far the most
                     informative: Adoc = AlignShop document. Could be confused with "a document"

   What will it contain? The tree structure of all individual data nodes with identifiers to its respective type of data.
   This includes: amino sequences, groups, root node, project nodes, primers, alignments, etc.

   o AshopTreeModel / AshopTreeNode - tying it to the name of the product. What if the product name changes? Same
     argument for Adoc{} and As{} I guess.

   Perhaps thinking in the box with always having to have TreeModel and TreeNode as a suffix...
   o AlignShopModel /

-- Model naming:

   o AdocTreeNode: Individual node that comprises part of the AlignShop document
   o Adoc: standalone class for manipulating an AdocTree (the data organizer components) as well
     the following:
     >> Creating skeletal database and document structure
     >> Read from database
     >> Write from database
     >> Rename database
     >> Maintaining an AdocTree (really just an AdocTreeNode pointer to the root of a tree)

   o AdocModel: base model for wrapping Adoc data class
   o AdocFolderFilter: takes an AdocModel and preserves only those Root / Project / Group AdocTreeNodes
     >> Targeting the left treeview pane in the MainWindow
   o AdocSimpleList: take an AdocModel and shows only the immediate descendants of a given location within the AdocTree
     as a simple list that may be modified and tweaked similar to that in the file view of windows explorer
     >> Targetingn the right treeview ("listview") pane in the MainWindow


-- During import, do a {begin,end}InsertRows on the AdocModel and then follow it up with the corresponding deal for
   the other active right pane model except do not insert anything. In essence a real data change on the one model and
   then simulate a dummy update on the other to have it update appropriately. I like it!

[5 Feb 2010]
-- The data organizer tree will be stored in the database as an MPTT tree (the columns may be viewed in the ddl.sql
   file). It is tempting to make a function that both reads the database table and returns an AdocTree; however, this
   would be tightly coupling the database and tree building functionality. Thus, the alternative is proposed:

   struct AdocMpttNode
   {
       QString type_;
       QString table_;   <-- ?? Do we need this field??
       int fkId_;
       QString label_;
       int lft;
       int rgt;
   };

   // Build Adoc Tree structure from list of MPTT nodes
   AdocTreeNode *tree = fromMPTT(QList<AdocMpttNode>);

   // Reverse direction: convert Adoc Tree structure into a list of MPTT nodes
   QList<AdocMpttNode> = toMPTT(AdocTreeNode *);

   >> Now this information can come from anywhere (database, file, network, etc) as long as it sends a list of
      AdocMpttNodes. In this specific application, we would read the data from the data_tree table and then convert
      this information into a QList of AdocMpttNodes.

      See drawings for final notes on this matter.

-- Would like to retrieve all data from the database / user file through the Adoc class (which will have the QSqlDatabase
   member). Is it possible to associate with each particular node type a given query (ie. the data it represents)? If so,
   then we could simply request the relevant slice of data for a specific AdocTreeNode. The Adoc class could then inspect
   the nodeType and then retrieve the appropriate data in the form of a QList<QVariant> and return that.

[8 Feb 2010]
-- All right, finally fleshing out the document classes and names:

   o TreeNode: generic Tree node
   o MpttNode: generic Modified Preorder Tree Traversal node (contains lft, rgt, and pointer to TreeNode)
   o AdocTreeNode: AlignShop document specific tree node
   o Tree: generic tree implementation with root pointer and handling typical tree operations

   o Adoc: AlignShop document class
   o AdocModel: base model for wrapping the Adoc interface
   o AdocFolderFilter
   o AdocSimpleList
   o AdocSpecificLeafFilter: filters out all nodes of a specific type organized into a flat list

[9 Feb 2010]
-- Initially, AlignShop was planning on locking the database files using QLockedFile; however, similar functionality
   may be obtained simply by using SQLite's built-in file locking. After opening a database file, simply obtain an
   exclusive lock:

   > pragma locking_mode = exclusive
   > {trivial write statement}

-- Some data integrity checks may be performed via: pragma integrity_check; however, this does not actually check for
   referential integrity. Too bad. Guess that is one of those things that really bothers me - how do I know that the
   data I am about to load properly relates? I suppose, just run several integrity queries:

   >> All sequences have a corresponding anonymous record:
      SELECT count(*) FROM sequences WHERE {x}seq_id is null
      --> Should return 0

   >> All subsequences should have a valid parent sequence id
      SELECT count(*) FROM subsequences a LEFT OUTER JOIN sequences b ON (a.sequence_id = b.id) WHERE b.id IS NULL;
      --> Should return 0

   Maybe this is not so much of a bad thing as it is a relatively easy way to check for integrity. Too bad, that SQLite
   does not do it automatically for us :| In any event, with a normal file we would need to do these checks anyways. Using
   SQL just makes it that much easier and more automatic. At least we know that the data will be more or less predictable.

-- So... data file integrity checking involves:
   1) pragma integrity_check;
   2) Ensuring that the expected tables and columns are present
   3) Ensuring referential integrity through various queries
   4) Validating the tree structure and organization

   So the kicker: how fast will this be? For large database files?

-- Permitted changes to the database file:
   o Addition of new tables given that they are prefixed with "user_"
   o Addition of new columns alongside existing columns given that they are prefixed with "user_"

-- An skeleton data file is one with DDL executed, a single unnamed project, and a tree with the root and project nodes
   >> How do we go about creating this empty schema?
      a) Store versioned DDL as resource and execute on demand
      b) Have alternative language for defining table names, columns, keys, and indices and use custom interpreter to
         execute those commands in a series. This would also facilitate checking DDL integrity, although it means more
         work.

-- Decided to go with option b for ease of analyzing and checking the data file. Will encode in JSON format and store
   as embedded resource for each version. Proposed v1.0 JSON structure looks like this (fields are strings unless
   otherwise specified):

   { version: X.Y,
     tables: [
       { name:
         comment?:
         fields: [
           { name:
             type:
             nullable?: boolean (default = true)
             autoincrement?: boolean (default = false)
             comment?:
           },
           ...
         ],
         primary_key?: [ field, ... ],
         foreign_keys?: [
           { fields: [ field, ...],
             ref_table:
             ref_fields: [ field, ...],
             update?: cascade (default) | restrict | set null
             delete?: cascade (default) | restrict | set null
           },
           ...
         ],
         checks?: [ condition, ... ],
         indices?: [
           { name:
             ifexists?: false (default)
             fields: [ field, ... ]
             table:
           },
           ...
         ]
       },
       // More tables
       ...
     ],
     pragmas?: [ pragma, ... ],
     queries?: [
       { name:
         comment:
         sql:
       },
       ...
     ]
   }

   ** [NOTE: 3 March 2010] No longer using JSON to represent the DDL specification. See comments on 3 Mar 2010

   >> Presumably, will be able to simply trust the JSON spec file (interpreted as a set of QVariants)
   >> By simply walking through the spec file, it is possible to automatically without any more information perform
      a referential integrity check. Scan all referenced tables from the foreign keys for matches.

-- Need to work out classes for interacting and manipulatingn this JSON structure. The tasks at hand include:
   o Checking that the JS is valid JSON (QScriptEngine)
   o Checking that the JS document properly conforms to the expected format (meaning, required columns are there)
   o Transforming the JS into SQLite compatible code
   o Given the JSON structure, check an existing database for integrity:
     >> Proper tables exist
     >> Proper column names exist
     >> Warn about extra tables/and or columns that are not prefixed with "user_"
     >> Referential integrity of all foreign keys
     >> MPTT tree contains only valid records
        - All tables point to real and expected tables
        - All foreign keys point to real records in the expected table
     >> Orphan records that are not associated with the tree (version 2.0)
        - This may not be that difficult given that the tree will stored MPTT style with table names. Simply scan perform
          LOJ against the appropriate tables and count.
        - Strictly speaking orphans are not a problem, but they will not be visible to the user because only items that
          are on the tree are visible to the user. Possible fix: create an orphan folder beneath the root and include
          all items here. May be tricky given that subseqs may be associated within the context of an MSA or seq.

-- The database specification file will be encoded in JSON and evaluated inside of Qt using QtScriptEngine. There will
   not be a separate class for representing this file format as it is a purely internal file and thus with appropriate
   testing should be safe to assume it has a predictable structure. But... then again, perhaps the developer made a
   mistake. Would be handy to track this down directly... so change of plans. There will be a Db specificaction class
   for just this purpose.
   o DbSpec - QVariant representation of a database specification

-- Converting the JSON spec file into SQLite DDL, executing the DDL, and checking the integrity of an
   existing AlignShop database file will be handled by other classes.

-- Task 1: converting QVariant spec file into SQLite DDL
   o SpecDdlEngine: abstract class with pure virtual function for taking a QVariant and returning QString of DDL.
                    Derivative classes contain the code specific to each database system for producing the appropriately
                    formatted and typed DDL.
   o SqliteDdlEngine: specifically outputs DDL for the SQLite dbms

-- Task 2: executing the Spec DDL
   o Adoc? Sure. For now at least. Get the spec ddl and then attempt to run it. Check for errors and report somehow.
     Well, maybe. All that is involved is executing a SQL query(ies). There is no added benefit to layering another
     function call around the QSqlDatabase::execute(...) function.

-- Task 3: checking the integrity of an existing AlignShop database file
   o DbIntegrityAnalyzer: empty constructor, methods for setting the database and spec ddl. Additional methods for
     specific checking:
     >> Tables exist and are properly structured
     >> Foreign key constraints are all valid
     >> Orphan nodes

[10 Feb 2010]
-- Not sure that the Tree class is useful. This morning in the shower, had the brilliant idea of placing the mptt
   conversion routines inside the TreeNode interface. Thus, it is incredibly simple to make any node immediately convert
   itself to a list of MPTT nodes or load from a list of mptt nodes. Swank!

[15 Feb 2010 - Monday]
-- Finished a basic version of a Perl script which translates a SQL DDL into its corresponding JSON representation that
   I derived earlier (see 9 Feb 2010)

[16 Feb 2010 - Tuesday]
-- Of course, perhaps it is not smart to intermix the MPTT functionality with the TreeNode interface. Just as easily
   could have a separate class that takes/returns TreeNode/MPTT lists.

-- Now we have the JSON DDL representation. Need to define the DbSpec interface.

   DbSpec: load(QTextStream)

   Adoc class to maintain the database connection.

-- JSON ScriptValue returns error information if it causes an exception:

   QScriptValue sc = ...;
   if (sc.isError())
   {
       sc.property('message').toString(); // Error message

       // Other properties
       lineNumber, fileName, stack. See QScriptContext::throwError and http://doc.trolltech.com/4.6/scripting.html#qtscript-extensions-to-ecmascript
   }

-- Turns out QScriptValue's are intimately tied to the corresponding QScriptEngine that they were derived with. Thus, if
   the engine goes out of scope...any QScriptValues associated with that engine turn to unusable goop and improper access
   will halt the program.

[3 March 2010]
-- Recently elected to utilize XML to represent the DDL structure rather than JSON. The major rationale for this is:
   o When combined with XML schemas, XML provides robust mechanism for validating and enforcing a particular data format
   o XML schema is mature framework for externally defining how a data file should look
   o Qt has large code base for reading/writing/parsing/validating XML files
   o The XML spec is purely an internal representation which the user will never see. Thus it is not important that this
     be easily editable and changeable by the user

-- Yesterday, finished the DbSpec implementation and testing everything except for the toSql() method. Originally, I
   was planning on separating this functionality into a separate class: SpecDdlEngine in the following manner:

   // Abstract virtual base class defining the interface for converting a spec into SQL queries
   class SpecDdlEngine
   {
       virtual QStrint spec2sql(const DbSpec &dbSpec) = 0;
   };

   // Concrete implementation of spec2sql for each database engine type
   class SqliteDdlEngine : public SpecDdlEngine
   {
       virtual QString spec2sql(const DbSpec &dbSpec)
       {
           // Code to convert dbSpec into SQLite compatible DDL
       }
   }

   However, for simplicity reasons and because AlignShop will currently only utilize a SQLite database, I have made a
   toSql() function inside of the DbSpec class that performs this operation. Not a good design principle, but good
   enough for version 1.0.

-- Huge leap forward in terms of error handling: QAbstractMessageHandler
   From now on (and need to make existing classes use this interface), all error reporting should be performed via the
   Qt Message Handler interface. Essentially, classes that need to have the ability to report errors will have a
   message handler pointer. After encountering a non-fatal runtime error, the error will be dumped via the message
   handler, which outside points of control may use to report to the user or take other necessary action. For instance,
   this is desirable when parsing data files, which if fails simply needs to alert the user of the exact problem:

   MessageHandler mh;
   ClustalParser cp;
   cp.setMessageHandler(mh);
   if (!cp.parse(...))
   {
       // Error captured in mh and can be reported to user
   }

[19 March 2010]
-- Originally was not going to have a separate tree class; however, perhaps it makes sense because it can provide a
   place to build some intial construction logic. For example, the constructor could be used to generate a boilerplate
   tree structure for all new AlignShop files.

[22 March 2010]
-- Having to think through the logistics of maintaining the data file and how this relates to the end-user experience.
   When the user begins AlignShop, it should create a new, empty document (Adoc). Creating an Adoc instance, does nothing
   besides prepare this class for usage. Similar to the QSqlDatabase class it is not ready for use until it has been "opened."
   So once the user begins AlignShop, we create an Adoc instance, and then call open without a filename:

   Adoc *document = new Adoc(DbSpec &spec);
   document->create(/*QString file = NULL*/);

   Opening the document does several things, if no file is given, a temporary file (SQLite database) is created for storing
   the data. Since this is a new document, we need to create the skeletal database structure based on a given DbSpec.

[24 March 2010]
-- While working through the testing and implementation of the Adoc class interface, I stumbled upon some SQLite idiosyncracies:
   o The SQLite parser will silently ignore extraneous non-keyword words. I specifically was goofed up by the fact on an
     autoincrement'ing column. SQLite has no support for the auto_increment keyword; however, it will parse it and you
     will be none the wiser:

     sqlite> create table test (id integer auto_increment);   -- Does not throw an error!

     I only learned this after having changed the database schema to use this underscore separated version :|

   o Moreover, to effectively use an autoincrement column it has to be defined as the primary key and on the same line as the
     field definition. For asethetic purposes, I had been separating the definition of the primary key from all field
     definitions; however, this resulted in wrong behavior and is incompatible with the proper use of autoincrement fields:

     sqlite> create table tests (id integer autoincrement, primary key(id));  -- Wrong! Throws syntax error
     sqlite> create table tests (id integer primary key autoincrement);       -- Correct!

[25 March 2010]
-- Potential abstraction: AdocDbSpec : public DbSpec
   o Would contain Adoc specific methods such as data_tree() which would return the table to read from for pulling the MPTT tree
     structure. In fact, if we standardized the AdocDbSpec interface, it significantly improves maintenance because only the
     AdocDbSpec class would need to be changed to recognize the proper tables.

   o In fact, maybe better than a separate class would be an internal configuration file (possibly editable by the end-user). Thus,
     to rearrange the various table names used would not even require a re-compile but rather simply editing a configuration file.

   >> How might this work? Take the Adoc::loadTreeFromDatabase() function. Currently, I'm hard-coding it to look in the data_tree
      table for all the MPTT nodes. If I want to change the table it uses, I have to edit every file that directly references any
      table of this nature. On the other hand, if AdocDbSpec contains a function: QString dataTreeTable(), which returns the relevant
      table to use, then all places where this table is needed should simply call dataTreeTable(). To effectively change this, I
      only have to update the dataTreeTable() function. This assumes that the AdocDbSpec interface does not change.

   >> I'm thinking that a better approach since this is purely a lookup based operation, is to simply store this information in an
      internal file and use standard names. No need for a full class just for lookups. Make this a hash of standard_table name ->
      actual table name.

[26 March 2010]
-- I planned to have Adoc::save truncate the data_tree in the database, then write it's in-memory tree to the database and then
   commit. This approach could potentially be a bottleneck with large projects. I'm thinking how this would work if there were
   tens of thousands of nodes (quite possible). Every time the user hits save, all 20,000 records are removed and then written to
   the database. Not so good.

   Maybe there is a better way of managing the tree. Perhaps lazily loading and updating this information from the database on demand.

-- Think the best approach is to probably keep a separate MPTT tree for each project, and actively manage the MPTT in the database.

-- Functions needed with respect to tree usage:

   o get immediate children nodes of type X
   o find all leaf nodes of a particular type
   o

-- Some benchmarks (on my beast of a machine that is :|), all inside transactions

   o Inserting into data_tree (type, label, lft, rgt) values ('group', 'dummy', 3, 5) without using a prepared statement:
     N           Time
     ---------------------
     1,000       83 ms
     10,000      461 ms
     100,000     4,251 ms
     1,000,000   42,240 ms

   o Same as above, except with prepared statement

     N           Time
     ---------------------
     1,000       64 ms
     10,000      51 ms
     100,000     2,324 ms
     1,000,000   22,745 ms

   o Reading entire data_tree set into QList<>

     N           Time
     ---------------------
     1,000       4.8 ms
     10,000      51 ms
     100,000     607 ms
     1,000,000   60,000+ ms

-- All right, figured out a great solution to determining if the AlignShop document has been tampered with: an embedded digest.

   Here's how it works. Checksum column in a metadata table. Set checksum = null, perform digest using QCryptographicHash and then
   save this value to the checksum column. Finish closing down the file. Next time the file is opened by AlignShop, read the checksum
   value and if it is a valid checksum, set checksum = null, crank digest and compare. If they are the same, it is safe to assume
   that the database is in an intact state and continue. Otherwise, if invalid checksum format or they do not match, perform all
   out database validation and notify user while doing these checks.

[29 March 2010]
-- Learned and implemented the mechanism for implementing custom SQLite functions:

   // Largely facilited by: http://www.mail-archive.com/sqlite-users@sqlite.org/msg01114.html

   o Add LIBS += -lsqlite3 to .pro file
   o #include <sqlite3.h>
   o Define relevant computational functions, in the case of the md5 aggregate this included the step and final functions:

    // NOTE: The various MD5 structures and functions are in the md5.h file
    static void md5step(sqlite3_context *context, int argc, sqlite3_value **argv)
    {
        MD5Context *p;
        int i;
        if( argc<1 ) return;

        p = static_cast<MD5Context *>(sqlite3_aggregate_context(context, sizeof(*p)));

        if( p==0 ) return;
        if( sqlite3_aggregate_count(context)==1 )
            MD5Init(p);

        for(i=0; i<argc; ++i)
        {
            if( argv[i] )
            {
                const unsigned char *x = sqlite3_value_text(argv[i]);
    //            printf("I: %d, value: %s\n", i, x);
                MD5Update(p, x, strlen((const char *)x));
            }
        }
    }

    static void md5finalize(sqlite3_context *context)
    {
        MD5Context *p;
        unsigned char digest[16];
        char zBuf[33];
        p = static_cast<MD5Context *>(sqlite3_aggregate_context(context, sizeof(*p)));
        MD5Final(digest,p);
        DigestToBase16(digest, zBuf);
        sqlite3_result_text(context, zBuf, strlen(zBuf), 0);
    }

   o Retrieve the raw database sqlite handle and register the function:

    QVariant v = db.driver()->handle();
    if (v.isValid() && qstrcmp(v.typeName(), "sqlite3*")==0)
    {
        // v.data() returns a pointer to the handle
        sqlite3 *handle = *static_cast<sqlite3 **>(v.data());
        if (handle != 0) // check that it is not NULL
            sqlite3_create_function(handle, "md5", -1, SQLITE_ANY, 0, 0, md5step, md5finalize);
        else
            die and output error!
    }
    else
        die and output error!

   o Utilize the function as normal: db.exec("SELECT md5(...) FROM table")

-- Original idea for rapidly validating whether a database has been tampered with:

   o produce digest of entire database file and somehow embed this into the file
   o After user has selected database file to open, extract stored digest. If there is none, assume it has been tampered with;
     otherwise, compute new digest and compare. If they are the same, it is safe to assume that no external changes were implemented
     and it is safe to continue without doing a full time-consuming validation.

   - After some research, think the actual approach to use is as follows: After each save, md5 the entire database file and append this
     to the binary sqlite file. Anytime the sqlite file is modified, this tag will cease to exist and we will know that the database
     has been modified. If for some reason, it is tweaked in an unexpected manner and the digest still exists, we can still validate
     the md5 digests.

-- The above approach is helpful, but still not ideal if the database has been tweaked or allowable changes have been introduced (e.g.
   the user adds data_* fields into existing tables. A easier method (although perhaps more time consuming) would somehow track changes
   on a per-table basis. Thus, we could store the md5 digest of each table in a distinct table and on load, simply compare new digests
   to stored digests for every relevant table.

   A preliminary step that will have to be done anytime that the global hash digest varies is that of checking that all the tables and
   expected columns are present and the right data types. Following this, then we can perform the relevant table-specific checks.

   >> Another advantage of this approach is that we can easily constrain the validation to critical columns and avoid/permit changes to
      unimportant fields (e.g. user-fields, labeling, etc.)

-- Performance measurements (debug mode, release compile showed minimal improvement) of md5(type, label, lft, rgt) of data_tree:

   sqlite> select md5(type, label, lft, rgt) from data_tree

     N           Time
     ---------------------
     1,000       1 ms
     10,000      9 ms
     100,000     90 ms
     1,000,000   961 ms

[30 March 2010]
-- Finished the Adoc base implementation and testing. A little complicated, but functional as desired. The next necessary layer is that
   of validating an opened database file. There are three levels of validation involved:

   1. Global - has the application file been altered since it was last opened in AlignShop
   2. Table - per-table scan basis using custom sqlite function, md5
   3. Row - ensure that each row is a valid entry
      >> With respect to maintaining referential integrity

   Additionally, the data_tree involves several layers of validation:
   >> Check for valid MPTT tree (this is already dealt with in the Adoc::loadTreeFromDatabase() function)
   >> Are all the foreign tables valid?
   >> Do all records in the data_tree point to valid records in their respective tables?
   >> Are there orphaned nodes in the other AlignShop-specific tables that are not stored in the data_tree?
   >> Is all the sequence data in the {x}seqs table normalized? Is the digest a proper base64-encoded SHA-1 digest of the normalized sequence?

-- Assuming that the validation layer is not immediately necessary and that we will only deal with valid data files. Will develop this
   component later.

[31 March 2010]
-- What to do about syncing project names and their labels on the tree?

-- Did some serious thinking about Object Relational Mapping (aka ORM). And came up with the following scheme:

   o Base class: DbTableModel
   o Derived class for each database table
     >> ProjectModel -> projects table
     >> AstringModel -> astrings table
     >> ...

   o Example of how this might work for say creating a new project

     void addProject()
     {
         ProjectModel project();                    // Create a record
         project.setField("name", "Undefined");     // Give it a name
         project.save();                            // Save to the database

         // project.id_ now contains the identifier of this record
         treeModel_->insertRow(QModelIndex(), root_->childCount(), 1, AdocTreeNode::ProjectNode, project.id_, project.field("name"));
     }

   o How to pull down data

     ProjectModel project();
     project.read(34);

     OR

     AseqModel aseqModel();
     aseqModel.read(34);

     AstringModel astringModel();
     astringModel.read(aseqModel.field("astring_id"));

     AnonSeq anonSeq(astringModel.field("sequence").toString());
     Seq seq(anonSeq);

     // Ready to roll with seq

-- These model classes actually better reflect individual rows within a table rather than the table itself.

-- Wonder about using the QSqlTableModel and QSqlRecord classes instead... Two downers:
   o Always have to specify the table and database right there. This makes changes a litle more work and potentially erroneous.
   > Could simply derive individual classes from these and customize ...

   class AgSqlTableModel : public QSqlTableModel
   {
       QString tableName_;
   }

-- Beef with QSqlTableModel
   o Unable to use prepared queries
   o It selects all fields and it is not possible to change this directly
   o Must enable going both directions in result set (would like option of only moving forward)
   o Have to execute another database driver specific query to fetch the lastInsertId... grr

-- Potentially derive from QSqlQueryModel
   o Have full control over query, but.... still must have bidirectional query ability

[2 April 2010]
-- Elected to roll my own ORM classes, even though this will require more work. Just seems to be a bit more close to what I need
   and customizable.

[5 Apr 2010]
-- For custom ORM classes, will simplify such that each class only reflects a single database table. Three primary functions will
   provide the core CRUD:

   read() :: SELECT
   save(), without NULL primary key :: INSERT
   save(), with primary key :: UPDATE
   remove() :: DELETE

   All complex find operations will utilize a different approach such as the QSqlTableModel.

   ProjectRow project(34);
   project.setValue("name", "New project");
   project.save();

-- Deriving from QSqlRecord turned out to be the most awesome place to start.

[7 Apr 2010]
-- Completed CrudSqlRecord and DbTable. Now it is readily possible to interact with the database via this simple ORM layer:

   CrudSqlRecord project(DbTable("projects"), <QSqlDatabase>);
   project.setValue("name", "New Project");
   project.save();

-- Need to build the GUI element that interfaces with these classes and currenlty the data_tree window.

-- Treeview goals:
   o Drag and drop with visual indicators of such
   o Icons

[13 Apr 2010]
-- Using QStandardItemModel / QStandardItem was a failure besides me figuring out how to bend my code to its ways and become
   familiar with its methods. The major hangup was lack of fine control over how the tree items are manipulated. This was
   especially problematic given my external tree structure. I initially pursued this option because I felt that it provided
   significant boilerplate functionality; however, in hindsight to make it do what I wanted to do would require significantly
   altering my existing codebase.

-- Thus, reverted to using AdocTreeModel (QAbstractItemModel) and AdocTreeNode to comprise my data tree. In this process, toyed
   with drag and drop, which works as follows:

   o User begins drag movement, which initiates the model::mimeData function where you construct one or more MIME representations
     of this data
   o When the drag ends, it is the user's responsibility to build the new nodes based on this MIME data; however, this is not so
     ideal given my external tree structure. I don't want to delete, create nodes. I merely need to pass the pointers of the ojbects
     to move. Thus, had to learn how to encode pointer data in a MIME object:


     QMimeData *mimeData = new QMimeData();
     QByteArray encodedData;

     QDataStream stream(&encodedData, QIODevice::WriteOnly);

     foreach (QModelIndex index, indexes)
     {
         if (index.isValid())
         {
             AdocTreeNode *node = nodeFromIndex(index);
             encodedData.append((char *)&node, sizeof(node));
         }
     }

     mimeData->setData("text/plain", encodedData);
     return mimeData;

     >> And read these pointer addresses back into memory:

     QList<AdocTreeNode *> pointerList;

     QByteArray encodedData = data->data("text/plain");
     QDataStream stream(&encodedData, QIODevice::ReadOnly);
     while (!stream.atEnd())
     {
         char buf[sizeof(AdocTreeNode *)];
         stream.readRawData(buf, sizeof(AdocTreeNode *));

         AdocTreeNode *node;

         memcpy(&node, buf, sizeof(AdocTreeNode *));

         pointerList.append(node);
     }

     >> Major thanks to this link: http://www.qtcentre.org/threads/18399-Dragging-a-pointer

-- Have not yet figured out how to translate a custom pointer object of a tree to its corresponding model index (similar to
   QStandardItem::index) easily. The only place where they meet without any outside information is the root. So I did the following:

    // Determine parent model index for all source items
    TreeNode *node = {treeNode pointer};
    QStack<TreeNode *> nodeStack;

    while (node->parent())
    {
        nodeStack.push(node);
        node = node->parent();
    }

    // At the root node, now work backwards through stack until we get the model index of the parent of {treeNode pointer} (thus
    // the z=...-1
    QModelIndex srcParentIndex = QModelIndex();
    for (int i=0, z=nodeStack.count()-1; i<z; ++i)
    {
        node = nodeStack.pop();
        srcParentIndex = index(node->row(), 0, srcParentIndex);
    }

-- Of course, it's also necessary to set the appropriate flags and view parameters as described in the docs.

[14 Apr 2010]
-- Believe I understand enough of the tree view mechanics to move forward; however, need to do some overall planning and design before
   moving forward.

[21 April 2010]
-- Making a custom class implicitly shared is not the most transparent process and all of the details are not explicitly mentioned.
   Here are the steps that need to be done:

   o Create the public class with the shared pointer in the public header file. It must have all four implicit class methods defined and
     none of these may be inline (http://lists.trolltech.com/pipermail/qt-interest/2010-March/019869.html):

     constructor(...)
     constructor(const MyClass &other)
     operator=(const MyClass &other)
     ~MyClass()

     Correction: no methods in this class may be inline!

   o In the cpp file, declare and define the private class and define the public class methods

[23 April 2010]
-- Major thoughts on pointers the past day or two and trying to sort out all the various differences between the ~8 utility pointer classes
   that QT provides (http://labs.trolltech.com/blogs/2009/08/25/count-with-me-how-many-smart-pointer-classes-does-qt-have/)

   1. QPointer
   2. QSharedDataPointer
   3. QExplicitlySharedDataPointer
   4. QtPatternist::AutoPtr
   5. QSharedPointer
   6. QWeakPointer
   7. QGuard
   8. QScopedPointer

   Shazam - what to think of all these? Obviously some form of smart pointer would be most helpful for intelligent memory management. But what
   do each of these mean? After several hours of reading and investigating, I think I have some idea of what is going on and can form an opinion
   on when to use what and where.

   For starters, a few of these are deprecated and/or not useful:
   o QPointer - apparently a weak old dog that does not perform as well as some of its more modern alternatives
   o QtPatternist::AutoPtr - internal class used primarily by the QtXmlPatterns module
   o QGuard - another internal class meant to succeed QPointer; however, it doesn't even appear to be present in Qt 4.6

   So that leaves us with the following:
   1. QSharedDataPointer
   2. QExplicitlySharedDataPointer
   3. QSharedPointer
   4. QWeakPointer
   5. QScopedPointer

   QSharedDataPointer :: adds implicity sharing of data to a custom class

   QExplictlySharedDataPointer :: same as QSharedDataPointer, except user must explicitly detach to obtain a unique copy of the data pointed at

   QSharedPointer :: strong, smart pointer that shares the pointer. Thus, the heap allocated object will always be alive as long as its reference
                     count is > 0. Ownership of the pointer is shared between all instances. Con: takes up twice the space of a regular pointer
                     and therefore will break binary compatibility.

   QScopedPointer :: strong, smart pointer that does not permit sharing of the pointer (effectively implemented by disabling the assignment and copy
                     constructor). It is freed when it goes out of scope. Thus it is mostly applicable in cases where you need dynamic allocation
                     in a stack-based manner. For instance, when allocating a derived class but utilizing a base class pointer to its interface.

   QWeakPointer :: weak, smart pointer sharing the pointer. It's major role is to indicate whether the raw pointer has been deleted or not; it
                   does not provide direct access to the data. These can only be created from a QSharedPointer. QWeakPointer may be promoted
                   to a QSharedPointer and if successful, then the object has not yet been deleted and then may be used as desired.

-- Given these diverse options, which should we adopt when coding AlignShop?

   Clearly, the QSharedDataPointer and QExplicitlySharedDataPointer are for sharing data and not so much passing around pointers. I also feel
   that these are inappropriate choices for derived classes. In other words, if I derive a class from QString (which is implicitly shared), does
   this make the derived class implicitly shared?

   QScopedPointer has limited application at this point, so the decision really boils down to working with QSharedPointer, QWeakPointer, and raw
   pointers.

   Return weak pointer to indicate that recipient does not own this resource
   return shared pointer, indicating that user will share ownership

   I guess it really boils down to ownership. If QSharedPointer is returned, that means recipient is the (or an) owner. If QWeakPointer is
   returned, that means recipient does not own it, but can use it for the immediate purpose.

   Will not utilize raw pointers unless explicitly stated.

   ** Exceptions: (Not 10 minutes into the conversion process and found an exception!)

   http://www.parashift.com/c++-faq-lite/virtual-functions.html#faq-20.8
   o clone() / create() - virtual constructor replacements. Specifically, it's not possible to have covariant return types with the QSharedPointer
                          class. Thus, it is the user's responsibility upon receiving a raw pointer of a newly created object from such method
                          to properly wrap it in a smart pointer as needed.

-- Convert a QByteArray to its const char * equivalent before utilizing it as a parameter in a prepared database query. Otherwise, it will not
   produce the desired result.

-- Need to convert QAbstractMessageHandler * to QWeakPointers

-- Considering whether to convert TreeNode to Q{Special}Pointers. It would certainly make the code much cleaner and tightly memory managed. Think I
   would have to utilize QWeakPointer - but who has the QSharedPointer

[26 April 2010]
-- Decided to just utilize raw pointers for the TreeNode structure - largely due to the fact that I could not figure out what to do with the parent
   pointer. I originally thought that I could make the children all QSharedPointers and the parent a QWeakPointer; however, how do you make a
   QSharedPointer out of this?

[27 April 2010]
-- Figured out how to utlize SharedPointer to this: static factory create function

   class TreeNode
   {
   public:
       static QSharedPointer<TreeNode> create()
       {
           QSharedPointer<TreeNode> object(new TreeNode());
           object->weakThis_ = object;
           return object;
       }

       void appendChild(const QSharedPointer<TreeNode> &node)
       {
            children_.append(node);
            node->parent_ = weakThis_;
       }

   private:
       QWeakPointer<TreeNode> weakThis_;
       QWeakPointer<TreeNode> parent_;
   };

-- Now the only question is: how does this perform relative to raw pointers?
   Created benchmark folder under the root directory and shared_vs_raw_tree_pointer test directory. Testing the building and traversal of tree using
   shared pointers and those just using raw pointers (5 levels, 20 children on each level = ~3.4 M nodes):

   Shared build: 3,221 ms
   Raw build: 2,407 ms

   Shared traverse: 1,963 ms
   Raw traverse: 232 ms

   Conclusion: raw pointers are faster and especially so when traversing the tree using a recursive function.

   But the above was done on a debug compile. How about the release version?

   Shared build: 2,050 ms
   Raw build: 1,913 ms

   Shared traverse: 1,245 ms
   Raw traverse: 120 ms

   Final conclusion: building tree with shared vs raw pointers has negligible speed difference; however traversing the tree is still much faster with
                     raw pointers (10x).

-- Occasionally will get an error like the following: undefined reference to vtable for '....' Add the class header file to the HEADERS section in the
   pro file.

[29 Apr 2010]
-- Just learned the hard way the essentialness of having a virtual destructor anytime you delete a derived class object via a base-class pointer. I was
   creating AdocTreeNodes and deleting them via TreeNode pointers; however, my TreeNode destructor was not virtual. This resulted in a difficult crash
   to debug. The only error message it returned was something to the effect of invalid free of pointer, which occurred during the TreeNode destructor.
   I put a qDebug inside the AdocTreeNode destructor and noticed it was not getting called during the delete of its base class TreeNode *. Adding virtual
   to the destructor declaration fixed everything. Swine!

   http://www.parashift.com/c++-faq-lite/virtual-functions.html#faq-20.7

[17 May 2010]
-- Now that Schlack has been implemented, back onto AS.
-- Goals for this week:
   1. Get the subversion repo moved to ageilgenomics.com
   2. Get Paul on board with Subversion
   3. Finish design and implementation of proxy models for viewing
   4. Basic sequence import design

-- Serious rethinking on the model structure and naming because this ultimately reflects how the models behave.

   1. Alignments will function as a container object that can hold arbitrary subgroups
   2. Only viewing mode control will be to toggle between amino/DNA/RNA/Primer/all entity types. There will no longer be the option
      to display: subsequences/sequences/alignments/primers. This simplification will make AS more user-friendly as well as easier
      to program.
      - All will display only those fields that are common to all entities which will at least consist of that entities label
      - Amino/DNA/RNA will display additional fields that are specific to that macromolecule type
   3. Seqs with subsequences will have a plus sign beside them indicating that it contains subsequences and when expanded will display
      the coordinates of such subsequences and whatever subseq specific information that may be useful
   4. When viewing an alignment, only display subsequence information alongside any relevant sequence fields (instead of the +/- collapse
      and expand buttons). Why? because sequences within an alignment may be arbitrarily ordered such that not all subsequences of a given
      sequence will form a contiguous group.
   5. All alignments will contain their own copy of a subseq object, which will be stored in a separate table (e.g. msa_subseqs). Each msa
      subseq will contain a foreign key to the parent seq object, such that changes to the sequence are cascaded; however, subseqs will be
      distinctly maintained and not visible in the normal tree views (due to the fact that they are in separate tables).
   6. If sequence type is incompatible with alignment being displayed, show in window link to convert the sequence type and thus display the
      sequences. If sequence type is all, then simply show the appropriate type of sequence data

-- Base model that contains and orchestrates all data manipulation: AdocTreeModel
-- Useful derivatives:
   o AdocContainerProxyModel: Exposes only container nodes (project, group, msa) and sorts them

   o AdocShallowListProxyModel: Sorts and displays all objects immediately beneath a given container. Container nodes are displayed first and
                              then all individual entities. Utilize with sequence type = all
   o AdocDeepListProxyModel: provides a flat view of all entities beneath the given container.


   o AdocAminoProxyModel / AdocDnaProxyModel / AdocRnaProxyModel / AdocPrimerProxyModel:
                         displays a sortable list of sequences (and subsequences) immediately below the selected container.

-- All right, the plan:

   o AdocContainerProxyModel
   o AdocListProxyModel (Abstract base class)
   |___ AdocShallowListProxyModel: simply displays the items beneath the currently selected container
   |___ AdocDeepListProxyModel: displays all nested items in a flat view beneath the currently selected container

   o Adoc{Amino, Dna, Rna, Primer}ProxyModel: proxies only AdocListProxyModel classes

[18 May 2010]
-- Asymmetric behavior with AdocTreeModel. Disentangling the creation/deletion of database records with regard to their owning objects.

   Naively, one might think that the existence of a ORM-type object (e.g. ProjectNode) should be intimately coupled with the existence
   of a database record (in this case a row in the projects table); however, this has undesirable side effects. For instance, when the
   application shuts down it must free all dynamically allocated objects. If the database record were to be deleted upon destruction of
   its owning ORM object, there would be no possible way of persisting database records beyond the single execution of AlignShop.

   Conclusion: ORM object lifetime will not be tightly coupled with the existence of a specific database record.

   It follows then that there must be a mechanism for inserting/deleting/updating database records via an ORM object. Because deleting
   a database record largely depends upon the primary identifier, it is possible to abstract this process and utilize the object-oriented
   virtual table to provide a general implementation as well as delegate specifics to concrete child classes. On the other hand, this is
   not possible with inserting and updating records because they will in most all cases require specific information (e.g. foreign keys)
   not present in the base class, AdocTreeNode.

   In QAbstractItemModel, removeRows is only called when data is being removed from the model, not when the corresponding objects are being
   deleted. Thus, it makes an ideal spot for also deleting any database records. Precisely what I will do. On the other hand, insertion
   and updates will have to be handled in a more concrete manner.

-- This approach is a much cleaner and consolidated means of handling the data. For instance, I had initially performend the database record
   removal from within the TreeView class in response to the Delete button. This was an ugly solution because it was not reusable and required
   that class to know the inner details of how to interact with the database. By placing this code within the model removeRows(...) function
   (which already is aware of the database, to a degree), it makes it possible to utilize this functionality from several different places
   and simplifies the coding and logic of the calling event.

-- Considering reducing ShallowList / DeepList to a boolean flag setting. Comparision:
   >> ShallowList
   o Displays container nodes (which have no columns)
   o 1-level deep
   o Since all entities are directly beneath the currently selected entity, the relative path is irrelevant and trivial

   >> DeepList
   o Does not display container nodes
   o N-levels deep
   o Utilize relative path

   In terms of rows, shallowlist has container nodes, while DeepList does not.
   In terms of columns, ShallowList has one less column than DeepList - the relative path column

   Option: make the RelativePath column always exist, but hidden when in the ShallowList mode.

   Suppose user toggles from ShallowList to DeepList. Actions: show relative column, reset. Vice versa. Shazam - that's not too bad!
   Well, actually its a bit more for DeepList. Specifically, would have to build flat array of all child nodes and use this to index
   into the relevant data slice.

-- The data and setData functions would have to be implemented to deal with this, but that also should not be too bad. Suppose the following
   structure:

   o AdocListProxyModel (Abstract base class): provides shallow/deep toggle and data functions for the relative path column
   |___ AdocAminoProxyModel: provides implementation to display all amino specific data
   |___ AdocDnaProxyModel
   |___ AdocRnaProxyModel
   |___ AdocPrimerProxyModel

   AdocListProxyModel would also be a concrete implementation that merely displayed the list of child AdocTreeNodes without any
   annotation information. In essence, this would be the all filter.

   AdocListProxyModel::setRoot(QModelIndex)

-- Because to the different access structures and methodologies between shallow and deeplist models, I once again am tending to place
   them in separate classes.

-- Side note: saving/retrieving void * inside a QVariant: http://blog.bigpixel.ro/2010/04/23/storing-pointer-in-qvariant/

[19 May 2010]
-- To accomplish a deep list approach that only shows the leaf nodes and still interacts with the main model would require subclassing
   QAbstractProxyModel, adding a setRoot(QModelIndex) function - which would cache all the leaf nodes in a flat list, and then hooking
   up all data change signals to update the cache on-demand as needed. From browsing the QSortFilterProxyModel code, this is a significant
   amount of work as there are several virtual methods (rowsAboutToBeInserted, rowsRemoved, layoutChanged, etc) that would need to be
   handled to keep the cache in a consistent state.

   Therefore, since this is a secondary issue, will not implement at this point in time; however, want to design the other classes such
   that it is future-compatible with this notion. Because of the modular nature of proxies this should be able to be integrated into
   the proxy pipeline on demand and without consequence apart from having to rewire any sourceModel() calls that expect to receive an
   AdocTreeModel instance.

-- Alternative approach to the deep list is to simply have add the ability to expand/collapse container nodes in the sub tree area. In
   other words, show a [+] if a container node has "compatible" (per any installed filter) children. Expanding this container node
   would then reveal the relevant children.

   Thus, there are two kinds of SubTreeProxyModels:
   1. DeepSubtreeProxyModel: provides hierarchical means of navigating the entire subtree
   2. ShallowSubtreeProxyModel: only shows the immediate children of a given node

   The major difference between this approach and the prior one, is that DeepList would transform the tree into a flat list of leaf nodes.
   This approach rather retains and exposes the hierarchy.

   Going forward class: AdocSubtreeProxyModel - only displays those nodes which are rooted beneath a given node. Moreover, has the
   option to display only immediate children or provide further nesting level.

-- Proposed model class architecture:

   o AdocTreeModel
   o AdocTypeFilterModel (ABC) : QSortFilterProxyModel
     :: virtual bool filterAcceptsRow(AdocTreeNode::NodeType nodeType) = 0
   |___ AdocContainerFilterModel
   |___ AdocAminoFilterModel
   |___ AdocDnaFilterModel
   |___ AdocRnaFilterModel

   o AdocSubtreeProxyModel : QSortFilterProxyModel || Displays all nodes beneath its root index
     :: bool isDeep()
     :: void setDeep(bool)
     :: setRoot(QModelIndex)

   Overall the configuration would look like:

   AdocTreeModel - contains all the data, master model
   AdocContainerFilterModel->setSourceModel(AdocTreeModel)
   AdocSubtreeProxyModel->setSourceModel(AdocTreeModel)

   >> If type filter is being used:
   Adoc{Amino,Dna,Rna,Primer}FilterModel->setSourceModel(AdocSubtreeProxyModel)

-- A major necessity would be to define specific Adoc roles inside AdocTreeModel and expose the AdocTreeNode pointer and methods via the data method.
   The specific setData and data functions that are tied to a specific column can be defined inside the concrete AdocTypeFilterModel subclasses.

-- Only remaining piece of the puzzle that I can think of is: how to specifically set the data via the database? if the AdocTreeNode * is exposable
   via the data method, we can cast it to the appropriate type for the AdocTypeFilterModel concrete class. Then using its methods can write to the
   database. Problem: the AdocTreeNodes, don't actually store the database reference. AdocTreeModel does though. Could expose this again through the
   data method as well.

-- Deep subtree is really an unnecessary construct when used in conjunction with a TreeView, because TreeView provides the option to setRoot and
   completely avoid having an intermediary proxy model. However, a shallow list does require such a model.

   Thus, it should be possible to simply create a ShallowSubtreeFilterModel which merely displays the children immediately beneath a node. For
   consistency though, I will simply make an option to have a subtree shallow or not.

-- Another thought is that of tagging sequences and/or nodes.

-- To declare a specific type into QVariant: http://lists.trolltech.com/qt-interest/2007-07/thread00021-0.html

   Q_DECLARE_METATYPE(MyClass *);
   MyClass *value = new MyClass;
   QVariant var = qVariantFromValue(value);

   // To retrieve the pointer
   MyClass *ptr = var.value<MyClass *>();

[24 May 2010]
-- Continuing to build and implement the various models pertaining to the data organizer.

   Because in general the views are intended to display both containers and a relevant sequence type, the Adoc{Amino,Dna,Rna}FilterModels will
   permit container nodes in addition to their specific type.

[25 May 2010]
-- When importing files, various things to consider:
   o File format
   o Sequence alphabet
   o Is the file valid given a particular format
   o How to detect file format automatically?
   o How to detect sequence alphabet automatically?
   o Is the sequence data aligned?

-- To help with this process, created global.h which will only contain globally relevant definitions and constants, etc. Specifically this
   includes an enumerated list of FileFormat's and SequenceAlphabet's

-- There are three major ways to detect the file format:
   o file extension
   o inspecting a relevant string
   o or both of the above given a valid file

-- Working with extensions has relevance to multiple parts of the program. Namely, it will be used by the class that inspects the file extension
   and in dialog boxes that need to create a name filter list. Thus it is advisable to encapsulate this in its own class.

   class ExtensionGroup
   {
       QString name_;
       QStringList extensions_;
       QString friendlyName_;
       FileFormat fileFormat_;

       ExtensionGroup(QString name, QStringList extensions, QString friendName = "", FileFormat = UnknownFormat);

       // Standard getter and setter functions

       bool contains(QString extension) const;
       QString nameFilter() const;

       // Static utility functions
       static QStringList nameFilters(QList<ExtensionGroup> extensionGroups);
    }

    Probably implicitly shared would be good implementation.

-- Class for detecting the file format could then take a QList<ExtensionGroup> and use that for inspecting if a relevant extension is found.

-- Would like to abstract the method for guessing the file format from a chunk of text (i.e. QString). This is where the Inspector class comes in.

   AbstractFormatInspector
     FileFormat inspect(QString) -- default returns UnknownFormat

   // Derivative classes could then utilize their own methodology for inspecting a QString and if it matched its respective format return the
   // appropriate format, otherwise UnknownFormat.
   FastaFormatInspector
   ClustalFormatInspector
   XXXXFormatInspector

   Then, could pass QList<AbstractFormatInspector> to FileFormatDetector, which could then utilize each one in turn to detect the file format. If
   an inspector returned any FileFormat other than UnknownFormat, we know its a winner.

-- Could produce entirely separte file format validator class as well; however, this code would largely duplicate the code contained in the relevant
   parser classes (e.g. FastaParser, ClustalParser, etc.). Furthermore, in most cases, the next logical step would involve parsing the individual
   sequences with these very parser classes. Thus, it makes more sense to simply attempt to parse them completely to detect if is valid and simultaneously
   extract the relevant sequences in the event that is indeed valid.

-- Similar approach for detecting the sequence alphabet.

   AlphabetDetector - controller class for detecting the various sequence alphabets

   AbstractAlphabetInspector
     Alphabet inspect(QString)
     Alphabet inspect(const BioString &)

   As with the file format, client could pass in QList<AlphabetInspector> to AlphabetDetector to use for detecting the sequence alphabet.

-- Final issue is dealing with conflicting reports, which hopefully should not happen, but depending on the exact Inspector implementations is very much
   possible. By conflict, I am referring to such things as the extension saying one thing and the format inspector another.

   Approach:
   1) If extension and inspector agree, then use this FileFormat
   2) If extension is empty and inspector is not, then use inspector FileFormat
   3) If extension is not empty and inspector is, then use extension (although this case should really result in an error of sorts). On the other hand
      if user did not pass any inspectors to the Detector class, then inspector result would be empty and not necessarily reflect an error.
   4) If extension and inspector are both non-emtpy and disagree, use inspector's result, but show warning

-- Overall example of potential flow:

   o User clicks File | Import...
     >> Create list of extension groups and pass the name filters to the file dialog
   o User selects file and hits open
     >> If filter type other than all has been selected, then use this filter type as the file format
        - otherwise, pass FileFormatDetector instance the same extension group list and an array of relevant inspectors
        - Get FileFormat via extension
        - Get FileFormat via inspector list
        - Compare and utilize above approach to return the file format

   Apply similar methodology for the sequence alphabet.

   o Given a file format and alphabet to work with, attempt to parse the file. If parse error, return with error. Otherwise, show listview of parsed
     sequences and whether they are valid relevant to the sequence alphabet with checkboxes for the user to select the desired sequences to import.

   o If the user changes the alphabet and/or format, repeat this process using the supplied parameters.

-- Considered making FileFormat a separate class that contained a pointer to an AbstractFormatInspector. This would then tie it all together. But,
   not crazy about this idea because there might be files to be recognized without an explicit extension. Of course though, could just have a fileformat
   class that does not have an extension. I like it!

[26 May 2010]
-- Buildilng a FileFormatSpec class - this will also provide a good place to put the enumerated File Format types.... or maybe not given that this is not
   a very extensible approach.

-- Finished the FileFormat class, now time to build and implement the various FormatInspector classes.

   What rules should be utilized to inspect a buffer and determine whether it is a FASTA formatted file?
   1. Ignoring all leading empty lines
   2. First non-whitespace character should be a greater than symbol '>'

-- Moving on to figure out the Alphabet crap.

   In some cases it will be ambiguous. For example, any sequence that consists purely of ACG's can be classified as either Amino, Dna, or Rna. Or similarly,
   any sequence that has ACGT or ACGU may be considered either Amino / Dna or Amino / Rna, respectively. The decision in these cases would be to then narrow
   the result down to the most specific case - the alphabet that has the majority of its characters present. In these last few cases, it would resolve to Dna
   and Rna, respectively, because they have smaller alphabets, which in turn means it had an overall higher alphacharacter representation.f

   So there is this notion of smaller/larger alphabets or its specificity. First off, how many alphabets are there?
   Amino
   Dna
   Rna

   And their strict counterparts, which limit them to their core/atomic nucleotides or residue codes. So roughly 6 alphabets with differing specifities.

-- Is it worth creating a separate Alphabet class similar to that done for the FileFormat class?

   In many ways it seems like a reasonable option given that this data could be used in multiple places (e.g. BioString validation, alphabet inspection, etc).
   But the major issue I'm running up against is that because of its static nature I would think I should use the Singleton pattern; however, it is not by
   default thread-safe and there is the issue of de-allocating the dynamically derived memory. Plus, I would want several distinct subclass alphabets available
   at any given time.

   Not too worried about the thread-safe issue because if it is needed in a multi-threaded context, we can simply ensure that it is created at some point
   within the main thread.

   Should be able to avoid the deallocation issue by using a smart pointer of sorts.

   Just found a cool helper class for simplifying singleton access - the SingletonPtr template class.

[28 May 2010]
-- Utilized a variation on the Strategy pattern to abstract the detection of FileFormats:

   Context: FileFormatDetector
     ::setInspectors(QList<AbstractFormatInspector *> inspectors)

   Strategy: AbstractFormatInspector via inspect(...) method
   Concrete strategies: FastaFormatInspector, ClustalFormatInspector

   Approach: FileFormatDetector takes a list of concrete FormatInspectors which each in turn check if they recognize the file format and return eUnknownFormat
             if it is unable to recognize its specific format.

   >> Thus, there are ultimately two layers of strategies:
      1. Abstracting different file format recognition classes
      2. Deciding from the array of inspector results, the single most likely FileFormat

      This second strategy is non-trivial when different inspectors claim different file formats for the same input_. How does decide in these cases?
      Presumably the file formats are distinct enough that this would not happen. Thus, we will simply choose the result of the first inspector that
      does not return eUnknownFormat; however, this may not always be the case as more file formats are supported and the more similar structure they have.

      Take for instance, Fasta vs Aligned Fasta. They are both Fasta Format; however, the difference arises in the sequence structure. Not sure how to
      deal with this at the moment. Technically speaking, it's not a different file format, but it is a different form of data which will result in a
      different treatment during import.

-- This second layer is really evident in the AlphabetDetector classes.

   Even with only one BioString, you can have multiple results to decide among. Take for instance the sequence ACG, it will be valid according to all
   three alphabet types. So in this case it is ambiguous. One approach would be to say since it covers a higher proportion of the Dna alphabet than
   the amino alphabet, it is more likely a dna sequence. However, it is also a valid RNA sequence... If there are multiple sequences, we can utilize
   contextual information. If there are other sequences with non-DNA and non-RNA characters, assume it is amino.

   The most flexible and ideal way for handling this is to separate the detection process into two separate strategy classes. The first decides the
   Alphabet from a single BioString. The second decides the final Alphabet from a distribution of Alphabets and perhaps any other contextual clues.

   Or could simply combine these into a single class with both methods. Unfortunately, while sipmler to implement, this design is not closed for
   modification nor open to extension. Two bad design issues.

   The naming soon becomes an issue here. In other words, what is a realistic, descriptive, and yet not-overly verbose name for such classes?


[1 June 2010]
-- Extra documentation code laying around that I didn't want to scrap even though it is unused:

  // MaxCoverageAlphabetDetector.h
  * Because this information is stored within BioStringValidator which
  * provides a means for independently changing the set of valid characters associated with an alphabet
  * determining the maximum covering alphabet would not necessarily be valid. Thus, after this happens
  * it is necessary to call sortInspectors to keep the MaxCoverageAlphabetDetector in a consistent state.
  *
  * To illustrate this, consider the following:
  *
  * AlphabetInspector aminoInspector(eAminoAlphabet, BioStringValidator(constants::kAminoCharacters));
  * QList<AlphabetInspector> inspectors;
  * inspectors.append(aminoInspector);
  * inspectors.append(AlphabetInspector(eDnaAlphabet, BioStringValidator(constants::kDnaCharacters)));
  *
  * MaxCoverageAlphabetDetector detector;
  * detector.setInspectors(inspectors);     // This also sorts the inspectors according their alphabetic coverage
  * ... // Do some detecting
  *
  * // Change the list of valid characters in the aminoInspector
  * aminoInspector.validator().setValidCharacters("ACD");
  * // At this point, detector still has a cached specificity of 20 for the aminoInspector (which translates
  * // into it being further down on the list of inspectors). To fix this, call sortInspectors, which will
  * // sort all the inspectors according to their vadliator character sizes in asecnding order.
  * detector.sortInspectors();
  *
  * // Continue detecting
  * ...

  void sortInspectors();                                      //!< Sorts the inspectors in ascending order based on their associated validator valid character lengths (ie. alphabet size)

  >> Corresponding test code:

  void TestMaxCoverageAlphabetDetector::sortInspectors()
  {
    BioStringValidator dnaValidator(constants::kDnaExpandedCharacters);
    BioStringValidator rnaValidator(constants::kRnaCharacters);

    QList<AlphabetInspector> inspectors;
    inspectors.append(AlphabetInspector(eDnaAlphabet, dnaValidator));
    inspectors.append(AlphabetInspector(eRnaAlphabet, rnaValidator));

    MaxCoverageAlphabetDetector detector;
    detector.setInspectors(inspectors);

    // Test: double check that the inspectors are in the expected order after setInspectors is called
    QList<AlphabetInspector> sorted_inspectors = detector.inspectors();
    QVERIFY(sorted_inspectors.size() == 2);
    QCOMPARE(sorted_inspectors.at(0).alphabet(), eRnaAlphabet);
    QCOMPARE(sorted_inspectors.at(1).alphabet(), eDnaAlphabet);

    // Change the {d,r}naValidator validcharacters after the fact
    dnaValidator.setValidCharacters(constants::kDnaCharacters);
    rnaValidator.setValidCharacters(constants::kRnaExpandedCharacters);

    // Re-sort and check that the order is appropriately updated
    qDebug() << "BLARLAXDFJLKSDFJA";
    detector.sortInspectors();
    sorted_inspectors = detector.inspectors();
    QVERIFY(sorted_inspectors.size() == 2);
    QCOMPARE(sorted_inspectors.at(0).alphabet(), eDnaAlphabet);
    QCOMPARE(sorted_inspectors.at(1).alphabet(), eRnaAlphabet);
  }

[2 June 2010]
-- Instead of having a separate table to contain the MSA subseqs, would rather have an extra field in the subseqs table that
   contains the identifier of its associated msa. If msa_id is null, then it is not associated with any MSA. Otherwise, it is.

   >> How to deal with entities after user selects them to be aligned? For instance, user imports 10 fasta sequences, selects
      them, and then aligns them. In this case, it is easy because without data reconciliation, only Seqs will be apparent and
      during the alignment creation process we can create full-length subseqs that are actually utilized by the MSA.

      However, suppose that the user imports 10 full-length sequences, defines several subsequences, and then aligns those. How
      should we deal with the subseqs then? I think the most transparent thing is to make copies of the subseq and assign those
      the corresponding MSA id.

-- Was thinking about the names of my nodes. I have labeled it a group node, which in reality is a virtual folder (virtual because
   it does not correspond to an actual folder on the hard drive). But calling these groups is much less intuitive than folders.
   So perhaps I should use the folder nomenclature? Or then again, maybe we don't want them to get these two concepts confused.

-- So, the file import. Can only pull in extraneous data from well-formed, standardized formats such as Genbank or the EBI stockholm
   files. Most of these should have recognizable files extensions as well, but that doesn't matter given the inspector/detector
   classes.

   At some point it will be desirable to import multiple kinds of data (trees, secondary structure, etc); however, for now, only
   support the importing of sequence data and in particular only fasta and clustal files because parsers for these have already
   been implemented.

   Action flow:
   o File | Import...
   o Selects file
   o Attempt to automatically detect format
     - If not successful:
       > alert user via messagebox
       > Set select one in the format combobox
       > select one for alphabet
     - If successful:
       > Set appropriate format in format combobox
       >

-- To utilize a qtdesigner form in one's application, Add new... | QtDesigner form with class. Then make the objectName = the actual
   class name. Otherwise it will spit out an "invalid use of struct..." forward declaration error.

   > For more details: http://doc.trolltech.com/4.6/designer-using-a-ui-file.html


[7 June 2010]
-- To add a flag, use the OR operator: flags |= Qt::ItemIsEnabled
-- To remove a flag with touching the rest: flags &= ~Qt::ItemIsEnabled

-- To specifically control the boundary limits of a header view's column, it is necessary to intercept the resize signals and resize
   the columns to the desired min/max size here.

[8 June 2010]
-- Must have a project before import/export is enabled.

-- Need select project/group node dialog which may be used in multiple places.

-- If you have a file and then after the fact add the Q_OBJECT macro, then you need to call qmake manaully or else, it will
   complain with errors like:

   Undefined reference to vtable...

[9 June 2010]
-- Not sure how to consolidate the creation of AdocTreeNodes. For instance, the need for creating projects and groups has surfaced
   in more areas than just the main window - it is also needed in the ProjectGroupSelectionDialog. Thus, the same code appears in
   two separate sections. This should definitely be encapsulated, but where and how? The bigger picture is that it will be necessary
   to call such creation routines from many different places.

   o Option: build list of specialized functions within the model class. But this doesn't make sense unless every time you create an
             AdocTreeNode it is explicitly added to the model. And this will not always be the case. For instance, when creating
             prototype nodes.
   o Option: separate AdocTreeNodeFactory

   Now the case of creating new project and group nodes is really not at the granular level of creating a project and group node. Rather
   the larger picture is to group the tasks - check if group can appear below a given node, create new project node, append to the
   model, and return its model index - into a single function call. The same goes for creating new group nodes. Thus, perhaps this
   functionality does make sense to add to the model class.

-- Idea for actually importing the sequence data.

   Given: array of ParsedBioString's, Alphabet, Format, and parent index of where to store result
   Setup: QHash<Alphabet, QScopedPointer<DbAnonSeqFactory> > dbAnonSeqFactoryHash
          --> dbAnonSeqFactory[eAminoAlphabet] = new DbAnonSeqFactory();  ->setDataSource(model_.databaseName(), "aseqs")
          --> dbAnonSeqFactory[eDnaAlphabet] = new DbAnonSeqFactory();    ->setDataSource(model_.databaseName(), "dseqs")
          --> dbAnonSeqFactory[eRnaAlphabet] = new DbAnonSeqFactory();    ->setDataSource(model_.databaseName(), "rseqs")

          QHash<Alphabet, QScopedPointer<SeqNode> > prototypeSeqNodeHash
          --> prototypeSeqNodeHash[eAminoAlphabet] = new AminoSeqNode();
          --> prototypeSeqNodeHash[eDnaAlphabet] = new DnaSeqNode();
          --> prototypeSeqNodeHash[eRnaAlphabet] = new RnaSeqNode();

   Algorithm:

     int project_id = model.data(parentIndex, ProjectIdRole);
     SeqNode *prototype = prototypeSeqNodeHash[Alphabet];
     DbAnonSeqFactory *factory = dbAnonSeqFactoryHash[Alphabet];
     QList<AdocTreeNode *> nodes;
     foreach (pbss)
     {
         SeqNode *node = prototype->create();
         node->createRecord(database(), project_id, pbss.bioString_, factory);
         nodes.append(node);
     }
     model.appendRows(nodes, parentIndex);

     if (Format == eClustalType)
     {
         // Create an alignment

     }

   >> Need method for easily getting project id of a given node. Perhaps, can give this a unique role and select it via the model data(...)
      function.

   >> Can use the labels of the individual sequence nodes for display purposes, and the base file name for the name of the alignment.
      At some point, need to implement dynamic labels, that are capable of intelligently integrating data from various fields into a
      single field that may be used as a label.

[17 June 2010]
-- Again struggling with the presentation of sequence data to the end user and the trouble primarily stems from the hierarchical treatment
   of sequences and subsequences.

   When a user imports/loads a sequence into AlignShop, they are going to expect to see a single row of data for that sequence; however,
   things such as multi-domain proteins, gene framents, and so forth all imply a greater context. Namely, that these sequences are really
   subsequences. The problem as I see it, is that while users understand this practically, they are not used to it implementation-wise.
   For instance, if a user loads in a domain (subsequence) of a larger protein sequence, we really have two things: 1) the full, owning
   protein sequence, and 2) a region within this protein sequence (the domain). Following this concept, it is obvious that an owning sequence
   can have 0 or more subsequences. And the protein metadata (e.g. organism, length, etc.) should be tied solely to the sequence yet be
   available to the subsequences.

   There are several reasons for modeling the sequence data as described above:
   o More natural and accurately representation of biological sequence data
   o Less storage space due to non-duplicated data
   o Easier cascading update
   o Provides easy mechanism for adding/removing characters from a subseq

   Current situation: most programs simply ignore this added level of complexity and look at each sequence as its own object indepedent of
                      its context. Thus, even if you have 2 domains from the same protein, changing any of the metadata in one domain sequence
                      would not cascade to the other domain sequence. Any features defined at the protein level would have to be duplicated
                      in the other.

   Problem: Lack of context makes sophisticated, yet highly desirable operations much more difficult and/or impossible. Moreover, because
            users are not used to the hierarchical approach in other tools, there will be an added learning curve in understanding how to
            interact and work with this additional layer.

   Observation: most work will probably not involve multi-domain proteins. There are relatively few users comfortable and/or knowledgable
                at that level; however, this does not mitigate the need for building a robust system that is future-proof and caters to
                power users.

   Observation: a full sequence is really a special case of a subsequence.

   Conclusion: Seqs will not be allowed to hang on the data_tree - only sub seqs. Seq data will be only displayed alongside its corresponding
               subseq data.

   View options:
   1. Flat view: display non-hierarchical rows at the subseq level with columns for both seq and subseq data. If multiple subseqs for a given
                 seq, then simply visually "duplicate" (not storage). Any change to the seq-level data would cascade to the other relevant
                 rows.

                 >> Most users will not know they are working at the subseq level because most will only have one subseq that takes up the
                    majority of its parent seq. Or even if they are working with a particular subseq (e.g. domain) that only spans a region
                    of the parent seq, chances are that there is only one instance of that subseq from that sequence.

                    Exception: what about users working with several different domains from the same protein? They'll just have to deal with
                               changes to a seq field automatically propagating to the other rows with the same seq.

                 >> Pros: Simple appearance, straightforward sorting
                 >> Cons: relationship between subseqs and owning sequences is not immediately obvious, must use signals to update the
                          appropriate seq level data of non-current rows.

   2. Hierarchical view: If there are is only one subseq for a given seq, display that row using the flat-style (above). If there are multiple
                         subseqs per seq, show the first subseq using the flat-style, put [-] beside it, and then display all remaining child
                         subseqs beneath this one without the seq metadata.

                         Eh... maybe not. Maybe display the first row with the seq-level data and then beneath it all its subseqs. The first row
                         would also contain the seq level comments. All its child rows would have the the subseq level data.

                         >> Pros: relationship between subseqs and owning sequences is very clear, allows for commenting at the seq level
                         >> Cons: sorting based on the subseq data is less clear

   3. Hybrid - allow the user to switch between the flat and hierarchical views. ** I LIKE THIS, flat view by default **

-- What happens when you want different subseqs from the same seq in different folders? For instance, suppose, I am working with LuxN and I have
   two separate folders: LuxN_9TM and LuxN_GAF. I would want one LuxN sequence, but different subseqs for that same seq in different folders.

   I suppose the treatment really comes down to utilizing subseqs for all sequence data and only allowing subseqs on the data tree. As desired,
   the seq data will be loaded on demand. A registry like mechanism, similar to that used for astrings.

   More formally,
   o There must be at least one subseq per seq
   o seqs are never permitted on the data_tree

-- Thinking about scrapping the projects table. I don't see what purpose it has beyond an extra level of categorization that could be provided
   by a group folder. Yeah, let's scrap it.

-- Question about merging the subseqs with seq display: How to deal with distinct labels? A subseq is really defined uniquely based on its
   coordinates. But it should still be possible to have duplicate regions with different names. Not sure why one desire this, but perhaps.

   The seq should definitely be provided with a name (e.g. protein / gene name or any other arbitrary user-based name). The subseq could then
   simply be a start-stop addition to this. Option: restrict subseqs to being unique (no two entries have the same start/stop coords). Option
   keep these separate but provide distinction based on its label.

-- Back to the model mechanism. The root model is the AdocTreeModel - everything will ultimately stem from that although it will have only
   lightweight responsibilities. Namely, it will be responsible for maintaining the data_tree, not so much for setting model data. A major
   function will be associating identifiers from the data_tree to records inside the database. From this, it will then be possible to pull
   in other relevant data from the database system.

   AdocTreeModel
   |___ AdocAminoFilterModel
        :: headerData()  --> here we define the relevant columns for viewing protein-type data
        :: data()        --> This will pull the relevant columnar data from the database
        :: setData()     --> This will set the relevant data in the database

[18 June 2010]
-- Method for reasonably showing results in AdocAminoFilterModel. In the data function, have two static variables, a subseq_id of the current
   subseq being displayed and a subseq instance. Initialize the subseq_id to -1 (or some other value that will is invalid). Whenever the data
   function is called, retrieve the corresponding subseq_id for that row. If it is different than the static subseq_id, reset the subseq by
   querying the database to populate the subseq object. Thus, for any given row, the database is only hit once. Perhaps do the same for the
   seq object.

   static int seq_id = -1;
   static Seq seq;
   static int subseq_id = -1;
   static Subseq subseq;

   int current_seq_id = parentModel::data(index, SeqIdRole);
   int current_subseq_id = parentModel::data(index, SubseqIdRole);

   if (current_seq_id != seq_id)
   {
       // Reload the seq data
       seq_id = current_seq_id;
       Seq = ...;
   }

   if (current_subseq_id = subseq_id)
   {
       // Reload the subseq data
       subseq_id = current_subseq_id;
       Subseq = ...;
   }

   // Display Seq and subseq data as requested.


-- Big question: how to pull the information from the database into a seq or subseq object?
   >> Could get the database from the parent model and then use CrudSqlRecord in this class. But then that mechanism is isolated here instead of
      a more reusable location (e.g. another class).

   Types:
   - AminoSeq / DnaSeq / RnaSeq
   - AminoSubseq / DnaSubseq / RnaSubseq
   -

   GenericObject(int id, Type type)
     o id_
     o Type type_
     o QHash<QString, QVariant> properties_

   AdocExchanger    // Knows how to exchange Adoc objects <-> generic objects
   :: Seq seqFromObject(const GenericObject &object)
   :: GenericObject fromInstance(const Seq &seq)

   AdocDataSource
   :: GenericObject create(const GenericObject &x) = 0
   :: GenericObject read(Type type, int id) = 0
   :: bool update(GenericObject &x) = 0
   :: bool delete(const GenericObject &x) = 0

   AdocDbDataSource(const QSqlDatabase &database)
   :: GenericObject create(const GenericObject &x)

   AdocDataSource *ds = new AdocDataSource(QSqlDatabase::database('alignshop'));
   Seq my_seq = e->seqFromObject(ds->read(AminoSeqType, 95));
   if (my_seq.isValid())
   {
   }
   else
   {
   }

-- Scrap the above junk decided new approach with DataRow, DbDataSource, and AdocDbDataSource. Was going to make it a more flexible system that could
   abstractly pull from database or file or whatever, but in terms of priority decided to code more to an implementation. For now, the data file will
   always be a database.

-- Scrap the Seq object altogether :) When user clicks on left hand pane, set the root index of the tree view. That will initiliaze the set of subseqs
   to display from the data_tree. When data is requested, it will utilize the associated AdocDbDataSource to read/write the seq and subseq data on demand.

   Special builder class and datasource function for gathering the MSA data.

   Now that a subseq is independent and can only exist in one location, things have gotten much more manageable. Meaning, when a user imports an alignment
   there will not be a separate section showing the sequence object with a separate-looking section of subseqs. Rather, there will be a single MSA node
   and all relevant subseqs stored underneath it. These are explicitly owned by the MSA and not otherwise. If a user wants to copy/paste them from the MSA
   node he may, but this will create a separate copy that will not affect the MSA subseq. Now, this does not apply to the sequence properties. The seq
   properties are stored only in the database do not have a separate object to manage them. Thus, when the user updates sequences properties in one location
   it will apply to all its subseqs.

   I guess following this logic, that it is possible to have identical subseqs in terms of their start/stop positions. They will still be unique based on
   their position in the data_tree.
   >> How does one create new sequences? Manually with a dialog box of sorts, fetching with external identifier, importing. I think this is normal
      and users wouldn't want it or think it should happen otherwise.

[24 June 2010]
-- After reading a freaking load of information about the pros/cons of exceptions, I have decided to use them! Why?

   o Google says they don't use them because error codes are not a signficant burden; however, on the face the benefits of exceptions outweigh their costs,
     and if starting from scratch (as we are with AlignShop), they would probably use them. This conveys that they are in favor of exceptions but legacy
     code is preventing them from making the switch

   o The function of the code is more apparent. The biggest kicker for me was how to deal with error handling. I'm used to a function returning the normal
     value if it worked properly. However, if you use error codes, you have to either return the error code and embed the output as a parameter to your
     function call; return a composite structure that contains both error information (if any) and the output (if no error); or utilize a special error
     struct that you pass into the function (as I did with the SimpleSeqParser and derivatives)

   o You can embed extra information and type data inside exception objects

   o Do not have to marshal error codes multiple levels because the exception will bubble up until it finds the relevant handler

   Potential cons:
   o Slightly more expensive, but I think this is minimal in the grand scheme of things.
   o Invisible execution paths - although this can be a pro. For instance an exception can bubble up to the relevant handler. The downside is that it is
     possible to miss the exact execution flow if one is not familiar with the code.

   Approach:
   o All exceptions that can be thrown from a function must be explicitly documented!!
     - By default, assume that the function does not throw any exceptions unless declared otherwise
   o Always derive from std::exception or some other universal base exception class that provides at a minimum a string explanation
   o Never utilize exception specifications except for perhaps throw() which indicates that it does not throw an exception (see link below)
   o Never throw exception from the destructor
   o Always catch a reference to an object
   o Utilize RAII to prevent leaking memory - this means using smart objects that take care of deleting themselves on destruction.
   o Leave the object in a valid state (exception safety) when throwing an exception
   o Swallowing catch clause (catch(...)) must be used with extreme caution!
   o Must never use exceptions for alternative execution paths

   o Currently, exceptions must be used for error handling only

   Extension specification issues:
   http://www.linuxprogrammingblog.com/cpp-exception-specifications-are-evil
   http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3051.html

   Neutral:
   http://www.codeproject.com/KB/cpp/cppexceptionsproetcontra.aspx :: good comparison article outlining the pros/cons

   For exceptions:
   http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Exceptions :: (actually they say don't use them, but that they would if starting from scratch)
   http://accu.org/index.php/journals/1505
   http://nedbatchelder.com/text/exceptions-vs-status.html
   http://nedbatchelder.com/text/exceptions-in-the-rainforest.html

   Against exceptions:
   http://www.joelonsoftware.com/items/2003/10/13.html :: StackOverflow co-founder
   http://blogs.msdn.com/b/oldnewthing/archive/2005/01/14/352949.aspx :: Raymond Chen's agreement and case for no exceptions

-- Plan: Do not derive from std::exception, but create our own universal exception class: Exception that is based on QString

-- To turn off debugging output, add the following to the pro file

   DEFINES += QT_NO_DEBUG_OUTPUT

[1 July 2010]
-- Do we set the lifetime of a AnonSeqFactory in Adoc to that of adoc itself or limit to from the time it is configured to the time close is called?
   Seems reasonable to think that it should only hang around until close is called.

[8 July 2010]
-- How to deal with various actions that depend on having an open adoc?

   Option A: Check for open adoc at the beginning of every action
   Option B: Connect/disconnect signals and slots in conjunction with open/closing an adoc
   Option C: Option B + Option A (for safety sake, also assert in the meantime)

[9 July 2010]
   @see 17 June 2010
-- Thinking through the flat/hierarchical views (with respect to making seq level objects function hierarchically) and think it would be better to
   simply utilize the flat view. I think revealing the actual use of seq level objects to the user would be confusing and counter-productive.

   Still will keep the hierarchical nature of groups, but just ignore the seq-level grouping. Perhaps utilize color to indicate other subseqs
   belonging to the same seq. Meaning, if the user clicks/edits on a subseq, highlight the background color of other sibling subseqs. Perhaps
   provide option to make unique by right-click menu.

-- Going forward plan:

   Seq level properties:
   o id
   o {X}string_id
   o organism
   o label
   o created
   o gene (dna or rna), protein (amino)

   Subseq level properties:
   o id
   o seq_id
   o label (see below for details)
   o start
   o stop
   o sequence
   o comments
   o created

   Subseq label is treated as a smart label. Defined variable names inside brackets are interpolated. Otherwise, the text is treated as the label.
   By default, the subseq label will consist of {parent}_{start}-{stop}. This can be changed in the preferences dialog.

   Flat view columns:
   Parent    | source        | gene/protein (optional) | Label        | Start        | Stop        | Sequence        | Comments        | Created
   Seq.label | Seq.organism  | Seq.gene/protein        | Subseq.label | Subseq.start | Subseq.stop | Subseq.sequence | Subseq.comments | Subseq.created

   Hierarchical view columns:

   << Collapsed >>
   [+] Parent    | organism      | gene/protein (optional) | Label        | Start        | Stop        | Sequence        | Comments        | Created
       Seq.label | Seq.organism  | Seq.gene/protein        ------------------------------------------ EMPTY ----------------------------------------
   [+] Parent    | organism      | gene/protein (optional) | Label        | Start        | Stop        | Sequence        | Comments        | Created
       Seq.label | Seq.organism  | Seq.gene/protein        ------------------------------------------ EMPTY ----------------------------------------

   << Expanded >>
   [-] Seq.label    | Seq.organism (editable) | Seq.gene/protein (editable)
       Subseq.label | Seq.organism (disabled) | Seq.gene/protein (disabled) | Subseq.start | Subseq.stop | Subseq.sequence | Subseq.comments | Subseq.created

   Columns may be rearranged and hidden as desired (saved in preferences).
   Problem: Where to display non-specific items (e.g. groups)? Under parent? I guess for now

-- Since AdocTreeModel does not store Seq-level nodes, the flat model above requires virtually no changes:

   rowCount() - simply # of subseqs
   data(...) - utilize static Seq and Subseq DataRows

   The Hierarchical mode, however, requires some significant wiring. Must compute the rowCount separately for a Seq node (# of child subseqs) and for a
   group node. Must work through all subseqs and count distinct seq ids. Moreover, finding data will require finding the nth distinct seq_ids and then
   pulling that data. Ugh.

-- To ease this pain, it is probably easier if we put Seq nodes onto the data_tree, but never display them directly. This complicates things a tad bit
   for the flat view though. Now to provide the rowCount for the flat view we have to sum the children of all Seq nodes. And to find the nth row for the
   data function, must loop through each of the seqs until we find the right one. This is a pain, but less so than just storing subseqs and having to poll
   the database.
   >> Possible issue: Now we have issue of having seq objects under both the msa node and elsewhere. For example, suppose I import 10 sequences and then
      create an alignment. Do we have a duplicate seq node under the newly created alignment as well as under the folder it was imported too?

   Another possible option is to give the AdocTreeNode arbitrary properties and simply store the seq_id underneath with each subseq. Then could just walk
   the subseqs. Or rather make a special SubseqTreeNode with the seq id property.

   Perhaps we can do some caching of sorts and tie into the update signals to keep the cache in a consistent state.

-- All right, model plan:

   o Keep the data tree as planned - do not add a seq node.
   o Flat view:
     - rowCount() = # of subseqs
     - data() = static seq and static subseq fetched from the database
     - setData() - if seq data is changed, find all subseqs with this seq id and emitDatachanged for these. Problem: various subseqs with the same seq
                   may be distributed all across the data_tree...:( Thus, may not be possible without some kind of seq mapping data structure.

-- Problem: since subseqs with the same seq may be distributed across anywhere on the data_tree, it is vital that Seq level changes associated with a
   given subseq are propagated to all relevant Subseq rows.

-- The only mechanism I can think of for tracing all this is to maintain an in-memory mapping of sequence ids to their corresponding model indexes.
   Some profiling with valgrind (valgrind --tool=massif ./TestBed):

    QHash<int, QSet<QModelIndex> > hash;

    for (int i=0; i< 1000000; ++i)
    {
        hash[i].insert(QModelIndex());
    }

    1,000,000 entries = 267.5 MB of RAM
    100,000 entries = 26.7 MB of RAM
    10,000 entries = 2.814 MB of RAM

    Utilizing pointers takes up slightly more space.

-- What if user is in the amino viewing mode and imports some DNA sequences? Despite successful import, there is no visual cue to the user of
   this operation. Need some mechanism of relaying success to the user. Perhaps a timed message to the status bar (showMessage)?

[12 July 2010]
-- Flat view easy:
   QHash<seq_id, TreeView *> nodeLookup

   as data function is called, populate nodeLookup as necessary

   Define different number of columns for each data type to be used and return appropriately from within the data function.

   In the setData function, anytime the seq data is updated, lookup all the relevant treenodes, resolve to QModelIndexes and emit DataChanged
   for these.

-- Problem: how to pull off the hierarchical view? I think we need to use a QAbstractProxyModel, that has additional rows for the seq level
   properties. But I cannot figure out how to construct a proper mapping algorithm.

[13 July 2010]
-- I have decided to avoid working on the hierarchical view mechanism as it is somewhat granular and serves more of a convenience role at this
   time. I think I worked out a proxy model implementation (in ScratchPad.cpp with the same date) and have provided a few skeletal functions
   should I revisit this in the future.

-- Plan: utilize the flat view and maintain a lookup hash of seq_ids -> TreeNode * in the AdocTreeModel class. Thus, whenever a sequence level
   element changes, all other subseqs can be updated:

   QHash<int, QVector<TreeNode *> > subseqs_;

   QModelIndex indexFromNode(TreeNode *)
   {
       // Using TreeNode functions determine location on Tree and map to its QModelIndex
   }

   void setData(...)
   {
       if (seq-level item changed && Nsubseqs for this seq > 1)
       {
           // Iterate through all seqs and emit the dataChanged element for them
       }
   }

-- Question: how to highlight those elements only in the current view? Cannot figure out how to do this.
-- Alternative approach: Somehow tag the elements that will be changed in the model when an edit of a sequence level object is initiated.
   Emit the dataChanged for these items which will trigger an update to its backgroundColor. Perhaps tag the TreeNode object. Or maintain
   a separate list of treeview pointers being edited:

   struct referenceSet
   {
       int row, column;
       TreeView *active;
       QVector<TreeView *> equivalents;
   }

   Process flow:
   - Empty referenceSet
   - User initiates edit on subseq organism
   - Using the subseqs_ lookup hash (see above), adds all relevant TreeView * to the referenceSet and triggers a dataChanged to all nodes
     being edited. This will cause the referenced nodes to display a different background color.
   - On finished editing, fade color to default background.

[15 July 2010]
-- Finished a prototype of a 1:1 proxy model! What a bear! The prototype is contained within mainwindow.h and mainwindow.cpp in r93.

[19 July 2010]
-- Decided to scrap the subtree proxy model class because it is completely unnecessary. Its functionality can be easily accomplished
   with existing Qt components:

   o Setting the root to a subtree can be accomplished via {QTreeView/QTableView}::setRootIndex(...)
   o To make a shallow list, simply use a QTableView
               deep list, use QTreeView

-- To get a datetime object from a string: QDateTime::fromString(<string>, Qt::ISODate);

   Qt::ISODate => ISO 8601 extended format: either YYYY-MM-DD for dates or YYYY-MM-DDTHH:MM:SS for combined dates and times.

-- Ideally would like to have a button on the far right of the horizontal header in a table/treeview that when clicked, opens up a popup menu
   with all the possible columns and in which the user can check/uncheck those to view or as a final option, restore the default. An exact
   implementation of this is done with Mozilla Thunderbird. From my google searches, I have not found a way to do this with qt. So, the next
   best option I think is to have the user right click anywhere on the header. Not as ideal an option but it works.

    ui_->treeView->header()->setContextMenuPolicy(Qt::CustomContextMenu);
    QObject::connect(ui_->treeView->header(), SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(onContextMenu(QPoint)));

-- To display all items, simply utilize the AdocDataTreeModel itself - it has one column and is exactly the right tree.
   All other filters will have a two-tier structure:

   AdocDataTreeModel -> VaryingColumnProxyModel -> (Amino|Dna|Rna)FilterProxyModel

[20 July 2010]
-- Drag and drop implementation:

   o Define Qt::DropActions MyModel::supportedDropActions() const
   o Define the flags for the relevant items in the flags method
   o Define a mime type:

     QStringList DragDropListModel::mimeTypes() const

   o Build the mime encoding function:

     QMimeData *DragDropListModel::mimeData(const QModelIndexList &indexes) const

   o Define the drop function:

     bool DragDropListModel::dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &parent)

   - To pass QModelIndices, simply subclass QMimeData, add a QList<QModelIndex> member, expose it, and create that object on th encode
     function. http://www.qtcentre.org/archive/index.php/t-13284.html

-- How to encode pointers in MimeData:

    QMimeData *mimeData = new QMimeData();
    QByteArray encodedData;

    QDataStream stream(&encodedData, QIODevice::WriteOnly);

    foreach (QModelIndex index, indexes)
    {
        if (index.isValid())
        {
            AdocTreeNode *node = nodeFromIndex(index);
            encodedData.append((char *)&node, sizeof(node));
        }
    }

    mimeData->setData("text/plain", encodedData);
    return mimeData;

-- How to decode pointers from MimeData:

    // Build pointer list
    QList<AdocTreeNode *> pointerList;

    QByteArray encodedData = data->data("text/plain");
    QDataStream stream(&encodedData, QIODevice::ReadOnly);
    while (!stream.atEnd())
    {
        char buf[sizeof(AdocTreeNode *)];
        stream.readRawData(buf, sizeof(AdocTreeNode *));

        AdocTreeNode *node;

        memcpy(&node, buf, sizeof(AdocTreeNode *));

        qDebug() << node->fkId() << node->foreignTable() << node->label();

        pointerList.append(node);
    }

    while (node->parent())
    {
        nodeStack.push(node);
        node = node->parent();
    }

    // At the root node, now work backwards through stack until we get the model index of the parent of pointerList_.first (thus
    // the z=...-1
    QModelIndex srcParentIndex = QModelIndex();
    for (int i=0, z=nodeStack.count()-1; i<z; ++i)
    {
        node = nodeStack.pop();
        srcParentIndex = index(node->row(), 0, srcParentIndex);
    }

    // Cannot add to same parent
    if (srcParentIndex.internalId() == parent.internalId())
        return false;

    // Now srcParentIndex is the parent model index of all rows to be moved
    AdocTreeNode *destNode = nodeFromIndex(parent);
    foreach (AdocTreeNode *node, pointerList)
    {
        int src_row = node->row();

        if (!beginMoveRows(srcParentIndex, src_row, src_row, parent, nodeFromIndex(parent)->childCount()))
            return false;

        // Extract node from parent
        node->parent()->takeChildAt(node->row());

        // Now node is dangling and a root node; attach to new position on tree
//        destNode->insertChildAt(beginRow, node);
        destNode->appendChild(node);

        endMoveRows();
    }

    return true;

[21 July 2010]
-- To utilize stylesheets in conjunction with a custom item delegate, it is essential that the custom delegate inherits from QStyledItemDelegate
   and not QItemDelegate.

[22 July 2010]
-- To ease switching between view types in the mainwindow, I elected to use a passthrough AdocTypeFilter for the actual AdocTreeModel. Thus it would
   be possible to polymorphically switch between these without the hassle of checking if we came from the TreeModel -> proxy, or proxy -> treeModel,
   or proxy -> proxy. If all were proxy models at the same level, then we could treat all cases as proxy -> proxy.

   After implementing this, the program crashed whenever there was at least one expanded node and user switched from a {Amino,Dna,Rna}FilterModel ->
   passthrough or vice versa. Specifically it would crash on the mapToSource() function call; however, when switching from {Amino,Dna,Rna}FilterModel
   to a different {Amino,Dna,Rna}FilterModel with expanded nodes - it worked as expected! The expanded model index is valid in both cases - what gives?

   Answer: The problem lies within the VaryinColumnProxyModel::setColumnCount(newColumnCount) function. In the current implementation, if newColumnCount
   is the same as the existing number of columns, nothing changes. On the other hand if they are different, VaryingColumnProxyModel resets the model.
   This in turn cascades to any dependent models (Amino, Dna, Rna, All items), which in this case are QSortFilterProxyModel's. I'm presuming that when
   the source model resets, QSortFilterProxyModel flushes its mapping, which corresponds to the saved expanded nodes. Thus, the call to mapToSource
   with what still appears to be a valid model index fails and results in the program crashing.

   Why did it work when switching from Amino/Rna/Dna -> Amino/Rna/Dna? This is a coincendental design fluke. At this point in time, each of these models
   has the same number of columns and thus the call to setColumnCount() did not observe a change in the number of columns and did not reset the model.
   Consequently, the expandedNodes array remained available.

   Solution: have setColumnCount() always reset the model to avoid these issues in the future, map all expanded nodes to the TreeModel before changing
   the column count, and finally map back to the final selected model.

[29 July 2010]
-- To utilize the gprofiler tool, add the following lines to the .pro file:

    QMAKE_CXXFLAGS += -pg
    QMAKE_LFLAGS += -pg

    # fomit-frame-pointer incompatible flag with pg
    QMAKE_CXXFLAGS_RELEASE -= -fomit-frame-pointer
    QMAKE_CFLAGS_RELEASE -= -fomit-frame-pointer

    > Make clean and make
    > Inspect the profile report via: gprof <executable name>

[30 July 2010]
-- To get QtCreator on windows with MSVC to build the forms properly, you must add CONFIG += uic to the .pro file.
-- Another issue on windows is that it tries to start an invalid executable because it does not point to the one it builds. Argh. Have to set the DESTDIR
   qmake variable to the corresponding place that windows attempts to use:

   DESTDIR = debug

   or

   DESTDIR = release

-- Had issue with unresolved symbols to the static functions in MpttTreeConverter. To resolve these, simply did a dummy edit (actually changed class MpttNode
   to struct MpttNode) and recompiled. wala.

-- If changes to the ui file do not seem to be having an effect (windows), make sure no ui file is in the trunk directory which will conflict with the
   uic generated one.

-- Release mode vs debug didn't seem to provide much of a performance boost. Think the limiting factor is probably the SQLite module.

-- A performance bottleneck when using QTreeView occurs when resizeColumnToContents is utilized. The definition of this function cycles through all rows
   multiple times which for a large model is quite excessive and unfeasible. Turns out that it originally only cycled through all visible items, but befire 4.2
   this was declared a bug and current implementation implemented since 4.2.

-- Three methods for boosting performance:
   1) Tweak SQLite parameters
   2) Load SQLite data in bulk rather than row by row
   3) Store exact data in specific arbitrary structure within AdocTreeModel itself

   o SQLite performance tips: http://web.utk.edu/~jplyon/sqlite/SQLite_optimization_FAQ.html

-- Another alternative is to utilize a tableview instead of a treeview. This would offer significantly improved performance at the cost of not providing
   a mechanism for navigating groups within the same window. The biggest issue I have with this is for MSA where it is desirable to see all groupings. I
   suppose an option is to create an additional column that holds the group and flatten the list. Mabye just have this within the MSA - but then how to flexibly
   move things around inside the list?

   >> Option: simply utilize tags to define groups of subseqs within a MSA and prevent groups from being allowed beneath a MSA.

-- Perhaps allow tags for all subseqs? This would make it possible to have a uniform view. But then again, this is not necessary given that msa's would not
   be displayed until clicked on.

-- BUG: for some reason, when hiding the itemTreeView widget and a varyingcolumnproxymodel is the view type, all rows are queried for data. Thus, when the
   application is closing, it can take a while to finish querying all visible items!
   RATHER: it only requests data for those columns with ResizeColumnsToContent set on them.

   Ok, got it:
   > When closing the application, all widgets are hidden. Any view widgets that have at least one column set to resizecontentstocolumn automatically, will
     cause the entire model to be queried for data as each individual item is hidden.
   > Thus, two fixes are possible:
     - Clear the ResizeColumns setting on any associated header
     - Set the model to null as needed

-- Just tested out windows build on Megan's desktop windows xp box. To get it working, needed these files:

   db_specs/db_spec-0.2.xml
   schemas/db_schema-0.2.xsd
   sqlitedrivers/qsqlite4.dll
   AlignShop.exe
   QtCore4.dll
   QtGui4.dll
   QtNetwork4.dll
   QtSql4.dll
   QtXml4.dll
   QtXmlPatterns4.dll

   Total of 14.6 MB

   Results: worked like a charm! Loaded and ran fast and responsive enough for desired usage.

[3 August 2010]
-- Qt Styling lessons:

   o selection-background-color: applies to the entire row
   o If specifying the selection-background-color, must also specify the selection-color if there is a property set with the :selected pseudo state
   o background-clip utilizes the box model and specifies the outermost rectangle to be used

   o show-decoration-selected => true; width = extent of treeview
                              => false; width = just that of the text

-- To get the treeview to only highlight the background of the text, the following must be done:

   1. Create custom delegate as follows:

class MyDelegate : public QStyledItemDelegate
{
public:
    MyDelegate(QObject *parent = 0) : QStyledItemDelegate(parent)
    {
    }

    virtual void paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const
    {
        if (option.state & QStyle::State_Selected)
        {
            QStyleOptionViewItemV4 styleOption(option);
            initStyleOption(&styleOption, index);
            QStyle *style = styleOption.widget->style();
            QRect textRect = style->subElementRect(QStyle::SE_ItemViewItemText, &styleOption);
            qDebug() << "Focus rect:" << style->subElementRect(QStyle::SE_ItemViewItemFocusRect, &styleOption);
            qDebug() << "Text rect:" << style->subElementRect(QStyle::SE_ItemViewItemText, &styleOption) << "\n";
            painter->fillRect(textRect, QColor(127, 0, 255, 255));  // Or other color/gradient here
            style->drawControl(QStyle::CE_ItemViewItem, &styleOption, painter);
        }
        else
            QStyledItemDelegate::paint(painter, option, index);
    }
};

   2. Then set the delegate for the appropriate view:

      ui_->treeView->setItemDelegate(new MyDelegate(this));

   3. Setup the stylesheet for the tree view as follows:

      QTreeView {
        show-decoration-selected: 0;
        selection-background-color: transparent;
      }

   >> The downside of this approach is that it locks the presentation into this delegate and requires a recompile
      with each change. The ideal option would be if we could somehow pull these values from a stylesheet setting.
      Could not figure this out.

   >> Good page with useful info: http://stackoverflow.com/questions/1956542/how-to-make-item-view-render-rich-html-text-in-qt

   Other useful links:
   o http://www.qtcentre.org/threads/13334-QItemDelegate-QTreeView-and-scrollbars
   o http://doc.trolltech.com/4.6/style-reference.html :: large data dump on how to make a custom style
   o http://doc.qt.nokia.com/4.6/qgradient.html

[4 August 2010]
-- The all items view should be a list view and not a table view. That way it will appear similar to windows explorer.

   To do this, one would use a QListView (flow: TopToBottom [default], movement: static [default], isWrapping: true, layoutMode: Batched
   resizeMode: Adjust, selectionRectVisible: true, viewMode: ListMode [default]

-- Ultimately decided that to get the exact effect I am after for drag and drop, will have to subclass the relevant views
   and reimplment the following functions:

   o mousePressEvent
   o mouseMoveEvent
   o mouseReleaseEvent
   o dragEnterEvent
   o dragMoveEvent
   o dropEvent

   Here's a link of how someone did something related for a QTreeWidget: http://www.qtcentre.org/attachment.php?attachmentid=1091&d=1177005395

[5 August 2010]
-- The best place for commercial icons seems to be: http://www.iconexperience.com

   Their basic-foundation V-collection is excellent. Only downside to using these folks is that the images are pngs and not vector-based. Argh.

[6 August 2010]
-- To respond to keyboard shortcuts (i.e. Cut/Copy/Paste) with signals and slots, use QShortCut:

   QShortcut *cutShortcut = new QShortCut(QKeySequence::Cut, ui_->itemTreeView);
   QObject::connect(cutShortcut, SIGNAL(activated()), this, SLOT(cutSelection()));

   and so forth... :)

-- Items will store whether they are in a cut or copied state. If new cut is triggered with already active cut, then
   prior cut is set to new cut items.

-- To pull this off, each view will need to respond to these events appropriately... ugh

-- Each view instance has its own selection model instance. Of course, these can be unified into single model
   via the setselectionmodel method.

[12 August 2010]
-- Really been struggling with the whole display sequence data display. It's awkward and difficult to display heterogeneous data within a
   view. While I have built a working version, it is sluggish and performs poorly. What I'm confident is needed is a locally managed 2D
   slice of data contained within the model.

   Why is it slow? When selecting a group node with any significant number of sequences, there is a load of methods called:

   For every M x N visible data cells, calls the index function to get a QModelIndex
     -> Each one of these is cascaded through the model chain:
        {Amino/Dna/Rna/Adoc}FilterModel :: VaryingColumnProxyModel :: AdocTreeModel
        -> The data function in AdocTreeModel then has to query the cache and load data one row at a time

   >> The proposed approach is as follows:
      - Slice (definition): a two-dimensional table data table for a specific type of node (Amino / Dna / Rna / etc.) populated with data
                            relative to a specific AdocTreeNode *parent; only contains the immediate children of parent that are either
                            groups or the specified type. Each node contains a record of its row within the AdocTreeModel

      - One model for every view
      - Slices are maintained externally in a manager class so as to promote sharing when possible (two different models observing the
        same parent and type) and avoid locking up large amounts of memory (ie. free it when no views are accessing this data)
      - Each model contains its own copy of the relevant slice (if any)
      - By tying into the signals of AdocTreeModel keep the slice up to date
      - the shared slice manager can push data change events to any associated models

   This would significantly bolster performance because the raw data needed for a given view would be stored locally within the model and
   the model class could intelligently and lazily read data in bulk from the SQLite database file.

[16 August 2010]
-- From the QAbstractItemModel.h header, QModelIndex::isValid() only returns true if the row and column are both >= 0 and the model is valid.
   Thus, it is not necessary to test that the row >= 0.

-- Finished prototype SliceModel implementation .... and it flies! Tons faster than the old approach and more modular design.
   Will continue to flesh out fully with documentation and testing.

[18 August 2010]
-- QVector: all memory is stored in a contiguous block; reserves space at the end for fast appending to the end

   Article on movable types: www.ddj.com/cpp/184401508

-- QList: two representations - 1) array of items on the heap (general case) or 2) stored directly (as with QVector)
   Reserves space at the *beginning* and the end. Prepend and removing the items at the beginning happen in constant time. This also allows
   to get faster insertion/removal in the first half of the list. How? Because it can always move the fewer amount of items (either towards the beginning or the end).

   QList also expands to less code in the executable.

   Why isn't there a reserve for QList? He doesn't know. It is added in 4.7


-- One case when QVector is better: if only doing appends. Can call reserve in advance when know the size apriori

-- For constant time insertions in the middle use QLinkedList

-- For OpenGL viewport, use full viewport mode because it does not support partial updating.

   OpenGL outperforms most anything else when it comes to drawing and especially so with pixmaps.

-- Platform specific optimizations:

   o Link time optimization: configure qt with "-ltcg" and regain 10-15% speedup. In most cases will work perfectly fine.

-- To get the SignalSpy tests working with QModelIndex's, do the following:

   1) Above the Test class definition: Q_DECLARE_METATYPE(QModelIndex)
   2) Inside the Test class constructor: qRegisterMetaType<QModelIndex>("QModelIndex");

[23 August 2010]
-- When accessing SQL results, it is much more efficient to index into the results using an integer value to specify the column of interest rather than
   utilizing a string name.

-- There are two specific sets of constants:
   (global.h) => View recognized columns and generally available external data
   (model_specific) => Actual columns pulled down from the SQL, all of which may not be visually displayed (e.g. ids)

-- For performance reasons, each model slice class will have its columns referenced via integer which are easily mapped using a set of
   enum's that correspond to the relevant columns. These may or may not be a superset of the global columns constants. By default, the
   model data function for the display role will only expose the global columns. To access other SQL specific columns, we define a new
   role, kSqlColumnRole, ... Bah - this isn't going to work because for each column a separate model index is needed and was not planning
   on exposing all the sql columns.

   On second thought, I guess it makes the most sense to actually map all columns of the slice into the data function. The ones that should
   not be displayed may be hidden via the tweakHorizontalHeader function. Will still keep the global constants alongside the model specific
   SQL columns. This will provide for changing the global constants order without having to rearrange the sql columns indices - we will simply
   have to update the mapping.

-- Generally speaking, a slice contains a fixed number of columns all of which may have valid QModelIndices. On the other hand, a slice may
   also contain non-standard column counts at variable positions. The best example of this is that of groups. A group occupies a single data
   cell and row within the slice. It contains only a single column.

   The interesting point is the group location within a table view. Which column does it appear under relative to the normal slice columns?
   This should be variable and if the header columns are changed (at compile time via the global.h), the group name should be updated as well.
   Consequently, it is not possible to say that the group cells will always be in column 0 or column X. This presents a slight problem for
   the SliceModel.cpp index function which decides whether to generate a valid index for a given row and column of a slice. It calls the
   virtual columnCount(Slice *, int row) function to decide if column is in a valid range; however, this is assuming that the slice columns
   begin at zero (and are contiguous). Need a mechanism for determining on a per-column basis for a slice if an index should be creatd.

   Solution: bool isValidColumn(Slice *, int row, int column) = 0 virtual function. This is called in the index function and subclasses decide
             whether the column is valid. If this method returns true, the base SliceModel class creates a valid index.

   Now group items are not necessarily fixed at the first column, but can move with column rearrangements.

[24 August 2010]
-- Visual flicker issue: When AlignShop first starts, the right hand pane shows a horizontal scrollbar for a few milliseconds before it
   quickly disappears. Probably has something to do with updates before tweaking the horizontal header.

[25 August 2010]
-- Interesting bug resulting from enabling fast concatenation: In cases where passing a implicitly constructed QString to a function, plus
   signs will not be caught at compile time and will crash the program. The disassembler is displayed and the only halfway informative line
   is mcount. No backtrace. Go figure. After stepping through the program to find the offending line it occurred when constructing implicit
   QStrings with the plus sign for concatenation. QT_USE_FAST_CONCATENATION must be defined for this error to appear. Solution: simply change
   the plus signs to percentage signs or utilize the QString %N and arg functions.

   #define QT_USE_FAST_CONCATENATION
   function doSomething(const QString &string)
   {
       ...
   }

   QString table = "amino_seqs";
   doSomething("The table of interest is: " + table);       // WRONG!! Will crash with an mcount error!
   doSomething("The table of interest is: " % table);       // RIGHT!

[26 August 2010]
-- Sorting a hash based on a complex object value. For instance, the DataRow access time in DbRowCacheManager

-- Undo/redo mechanism

   >> Utilize temporary table triggers to write all database undo operations to a database table (e.g. undo_log). For an example implementation
      see http://www.sqlite.org/cvstrac/wiki?p=UndoRedo

   >> Utilize the Qt Command pattern to push undo/redo objects corresponding to user events. For the data organizer, these will take place at the
      model level.

      Insert new nodes
      :: undo -> AdocTreeModel::removeRow(x)
      :: redo ->

   >> Eh... this will be messy.

-- After removing subsequences, it will be desirable to remove orphan sequence rows and possibly orphan astring rows. This can be performed very
   quickly with the following queries (demonstrated for amino sequences):

   DELETE FROM amino_seqs WHERE id IN (select a.id FROM amino_seqs a LEFT OUTER JOIN amino_subseqs b ON (a.id = b.amino_seq_id) WHERE b.id IS NULL);

   -- And if we wanted to delete those astrings with no sequences entries, the SQL would be as follows:

   DELETE FROM astrings WHERE id IN (select a.id FROM astrings a LEFT OUTER JOIN amino_seqs b ON (a.id = b.astring_id) WHERE b.id IS NULL);

   -- If foreign keys are setup properly, this delete should cascade to all the stored data at the astring level.

-- Considering scrapping the foreignTable field from AdocTreeNode. Not sure how it helps anything since we are not utilizing that field anyways.

-- For many simple tests that do not require a full GUI, it makes sense to have an appless_main (ie. QTEST_APPLESS_MAIN); however, in some instances
   it is necessary to have a QApplication for the test. In particular, this occurs whenever the need arises to QXmlSchemaValidator (e.g. DbSpec).
   I was attempting to test AdocDbDataSource using the standard AlignShop schema loaded via DbSpec and I kept getting this error:

   QWARN  : TestAdocDbDataSource::eraseRecords() QEventLoop: Cannot be used without QApplication

   What is that all about? After about 10 minutes of poking around, I concluded that it was because I did not have an actual QApplication object.
   Why? Because at the end of the test cpp file, I declared:

   QTEST_APPLESS_MAIN(TestAdocDbDataSource)

   Changing this to QTEST_MAIN(TestAdocDbDataSource) remedied the problem.

-- Erasing subseqs is now implemented in a very swift manner via AdocDbDataSource. Still need to provide interface for removing orphan nodes using
   the above queries. AdocDbDataSource seems to be the most fitting place for this at the moment. Would need fine-tuned control of "purging". Something
   to the effect of:

   void removeOrphanRecords();
   void removeOrphanAminoSeqs();
   void removeOrphanAstrings();

   Or could make it take a list of tables:

   void cleanTables(QStringList tables);

   >> Seems like this would best be accomplished via delegation of sorts especially given the specific table knowledge needed to purge accurately. Then
      again, could probably just build a hash of canned queries for a given table name that would do the desired purging:

      constants::kTableAstrings -> DELETE FROM astrings WHERE id IN (SELECT * FROM astrings a LEFT OUTER JOIN amino_seqs b ON (a.id = b.astring_id) WHERE b.id IS NULL);
      constants::kTableAminoSeqs -> ...

      - Of course, in doing this the order would be very important. For example, in just the above two statements, kTableAminoSeqs should be handled
        before kTableAstrings as this might uncover additional "orphaned" astrings.

   Or could have a multi-tiered hierarchy corresponding to major sequence blocks:

   removeOrphanAminoRecords();
   removeOrphanDnaRecords();
   removeOrphanRnaRecords();

[27 August 2010]
-- {Amino,Dna,Rna}SliceModel testing - much of it does not need testing since it is simplistic and GUI related. For instance, take the columnCount function and
   headerData functions. These could easily change if I change my mind regarding which columns to show. The only functions possibly necessary to check that I can
   think of are createSlice, setData, and possibly isValidColumn.

-- Example of how to iterate through complex hashes is given below. This example is currently not-implemented but was the beginnings of trying to map all seq ids
   to their corresponding slice rows in AminoSliceModel.

void AminoSliceModel::sliceAboutToBeRemoved(Slice *slice)
{
    // Remove all indexed slices
    QHash<int, QHash<Slice *, QSet<int> > >::iterator i = seqIdToSliceRows_.begin();
    while (i != seqIdToSliceRows_.end())
    {
        QHash<Slice *, QSet<int> >::iterator j = i.value().begin();
        while (j != i.value().end())
        {
            if (j.key() == slice)
                j = i.value().erase(j);
            else
                ++j;
        }
        if (i.value().isEmpty())
            i = seqIdToSliceRows_.erase(i);
        else
            ++i;
    }
}

void AminoSliceModel::sliceRowsAboutToBeRemoved(Slice *slice, int start, int end)
{
    // Find any indexed slice (there can only be one)
    QHash<int, QHash<Slice *, QSet<int> > >::iterator i = seqIdToSliceRows_.begin();
    while (i != seqIdToSliceRows_.end())
    {
        QHash<Slice *, QSet<int> >::iterator j = i.value().begin();
        while (j != i.value().end())
        {
            if (j.key() == slice)
            {
                // Now remove these rows from the set as needed
                for (int k=start; k<= end; ++k)
                    j.value().remove(k);

                // No need to do any more processing
                return;
            }
            else
                ++j;
        }
        ++i;
    }
}


[30 August 2010]
-- QTableView appears to request current data from most currently visible cells* whenever an item is updated via a delegate but not when calling setData outside
   of a specific delegate. By most visible cells, it did not request an update for group items (which only have their corresponding column index as valid). The
   test: issue a qDebug for each index data is requested for and then update via the delegate vs pushing a button that calls setData.

   This is confusing because I would have expected that regardless of the mode by which the model was updated only those cells that intersected the dataChanged
   event would have been updated. Not so!

[31 August 2010]
-- Layering a QSortFilterProxyModel over the SliceModel's would briefly show the appropriate header column names and then they would disappear. At some point the
   hidden columns were visible too. Stepping through the code narrowed it down to the loadSlice function and it apparently had something to do with inserting rows.
   I believe this is due to the fact if loadSlice is not called, there are no rows and this somehow affects the headerData method. More investigation revealed that
   the problem was caused by the SliceModel::index function which did not create valid model indices for Group type nodes except for its name column:

    // Top-level items
    if (!parent.isValid())
    {
        if (column != 0)
            return QModelIndex();

        ...
    }

   By commenting the above, the QSortFilterProxyModel was happy again. Strange. I wonder if QSortFilterProxyModel requires fully indexed tables. In other words,
   that if you have a MxN table there must be MxN actual indices for it to function properly.

   Another interesting issue was occurring with slice items. If a group contained another group and sequence data, whenever a header was clicked to perform
   a sorting operation, any hidden columns would suddenly appear. On the other hand if only sequence data was displayed in the view, any hidden columns (e.g.
   Amino subseq ID) remained hidden. What gives? Turned out that I only created indices for one of the columns for any group items (because it only has one
   column of data). Apparently this causes issues. Once I create indices for all columns of all rows, this problem disappears. I suppose it is due to the sort
   method requesting data for a non-existent data cell although I think this would just devolve into a comparison of QVariants...apparently it's more than that.

[1 September 2010]
-- Thinking through the sort process. Using QSortFilterProxyModel provides a good amount of tested, usable code. But it comes with certain constraints. Namely, that
   that it is necessary to create model indices for cells that should not have them (e.g. neighboring group columns). This then means that testing must be done in
   the individual data methods for valid nodes. For example, in the data function, must check that the column is group node and in column one.

-- All right, I believe my original understanding was wrong. Specifically, columnCount(parent) returns the number of columns for all children of parent. Thus, it
   is not correct to only create indices for some columns of some rows. Doing so goes against the specification defined by the Qt Model/View framework and results
   in downstream issues with such classes as QSortFilterProxyModel. While it is feasible to avoid these by creating a replacement proxy model to QSortFilterProxyModel
   this is probably not in our best interests at this point in time.

   All the same, creating our own sort proxymodel would be the most performant as it can be tailored directly to our data representation and circumvent the overhead
   associated with QSortFilterProxyModel's general implementation.

   But... QSortFilterProxyModel appears to still have an issue even if all the children of a given node have the same number of columns but different levels in the
   hierarchy have differing numbers of columns. Specifically, in the SliceModel, root children have 1 column (top-level indices), and top-level children have N columns
   (slice items). If N != 1, QSortFilterProxyModel does not show the headers properly nor does it sort when clicking on the headers; however, if I specify that no
   matter the parent, SliceModel::columnCount() returns a constant, then things work as expected. Ugh.

   Thus, it appears that for this to work properly, an absolute number of columns must be returned for a given model that is going to be chained to a QSortFilterProxyModel.
   Swine.

-- CONCLUSION: We will use QSortFilterProxyModel - would take too much effort to recreate these classes at this time and the payoff would be minimal. In order to do
   so, columnCount of all SliceModel inheritors will be a constant number regardless of the supplied parent index. However, it is vital that relevant functions in subclasses
   do not attempt to access or utilize these indices. Thankfully this is easily performed by utilizing the getParentSlice() method which will return a null pointer
   if the supplied index does not correspond to a valid slice item. Although it is still necessary for single cell nodes (e.g. group nodes) to not return any data
   for them apart from their designated column.

-- Chained model pointers and potential crash on program exit:

   Situation: several slicemodel pointers and one QSortFilterProxyModel pointer. All allocated on the heap with parent to MainWindow and set to be freed when MainWindow
   is destroyed. Problem, when the proxymodel sourceModel is a slicemodel and the program is closed, the application crashes with the error: "Pure Virtual Function Called"
   and jumps to the endResetModel() point inside the SliceModel::clear() method. What happened? Turns out that the ProxyModel was created after the slice models and
   thus the slice model was deleted before the proxymodel. This is problematic because the proxymodel now contains a dangling pointer to a deleted model. The endResetModel()
   method triggers the proxyModel to update its contents and therefore, tries to access an invalid location = CRASH!

   Three possible solutions:
   1) Allocate proxyModel (with its parent being the MainWindow) *before any other model pointer is allocated* that the proxy model might source. This sidesteps the issue
      and is a little more performant because the proxy model will be freed before any of the slice models.

   2) In the MainWindow destructor, set the proxy model source model to Null effectively disengaging it from any slice model. Thus, when the QObject hierarchical delete
      kicks in, it doesn't the matter that the model objects were instantiated.

   3) Explicitly delete the model objects in the proper order in the MainWindow destructor instead of relying on the QObject hierarchy delete

   Hybrid) both 1 and 2 together. I don't like just option 1 by itself because I will probably forget that the order matters at some point and could possibly recreate
           this problem at some point in the future or during refactoring / code cleanup.

-- Potential huge speedup by simply not releasing the slices... but at the cost of being a memory hog! :)

-- Improved the testing of the SliceModels by including database checks although only for a sequence column. The reason for not more fully testing setData with each
   column is because this information is likely to be fluid. When the data to be displayed is more or less settled upon, will revisit this testing and ensure that
   all data in all tables is updated as expected.

[2 September 2010]
-- Implemented improved sort proxy model that always displays groups first and then all other items and applies the current sort mechanism to these individually. To
   achieve this effect required subclassing QSortFilterProxyModel and overriding its lessThan virtual method and applying the proper logic.

   Because this function may be called many many times (relative to the number of rows being displayed), it is vital that it perform as fast as possible. Moreover, it
   is necessary to know the sort order such that the appropriate value may be returned to make groups always be displayed first.

   Gotcha: For slicemodels containing both non-group items and groups, the implementation would swap the order of the groups even when all cells corresponding to group
           rows under this column were empty. The reason: the SliceModel data function was returning an invalid QVariant. This in a sense is correct, but goofs up the
           sort mechanism.
   Solution: For all unused cells, do not return an invalid QVariant(), but rather a null, valid QVariant (e.g. QVariant(QVariant::Bool)). This then returns the expected
             result and sort functions as desired.

-- Just inspected the size of AlignShop binary size created under release mode and it was ~9.2 MB! Shazam. Turned out there is a linux program called strip that removes
   all sorts of symbols from the executable. After stripping AlignShop, the file size was just over 1 MB. Wow!

   http://lists.trolltech.com/qt-interest/2006-05/msg00194.html

[14 September 2010, Tuesday]
-- Drag and drop details. Flags are utilized to convey state and allowable actions to the caller. Based on the returned results, the caller should responsible issue
   requests for mimeData, dropMimeData, etc to successfully implement a drag/drop operation. However, due to the public exposure of the mime methods, it is not possible
   to assume that the input contains valid data. Unfortunately, this then incurs the overhead of checking that the provided data is valid.

   On the other hand, if we state the assumptions clearly and up front, perhaps we can avoid extra checking code and operate from an assumed context. Meaning, if dropMimeData
   is called, assume that it was issued via an ItemView (except for testing purposes). We should be able to make this assumption because we designed and implemented the
   program. This should be possible but only if it is expressly documented.

-- Drag and drop is complicated. If the dropAction is MoveAction and dropMimeData is successful, then Qt behind the scenes automatically calls removeRows for those rows
   that were active during the drag process. In effect, you cannot truly move rows. They must be recreated somehow (within the dropMimeData method) and then inserted.
   If this is successful (return true from dropMimeData), the rows are then removed.

   So... moving forward, the plan is:

   >> Relevant views should have a DragDropMode of DragDrop - not InternalMove (which only permits move operations within itself)
   >> defaultDropAction = MoveAction - copy is not allowed
   >> dragDropOverwriteMode = false; this ensures that the rows are removed and not cleared during move operations
   >> dropMimeData: assuming it received valid input data, create duplicate rows with duplicate TreeNode pointers, but remember those rows that should not have their
                    source TreeNode pointer freed when removeRows is called. This avoids releasing the memory and crashing the program :)

[15 September 2010, Wednesday]
-- dropMimeData. If a drop occurs on an item, parent = item dropped onto and row = column = -1. On the other hand, if the drop occurred before/between/after an item but
   not on an item, then the row and column will be set appropriately. Specifically, row equals the drop point. If there are three rows - A, B, and C - and the drop occurs
   between B and C, the row value would equal 2. Column behaves similarly.

-- Any IgnoreAction should return true in dropMimeData but do nothing with the data. Observed from Qt example code.

-- The drag and drop model methods are only intended to be called from an attached ItemView otherwise, unexpected behavior may result. For instance, when testing SliceModel
   with mockModel that calls these functions directly, it does not have a clearOrRemove method (which is responsible for moving the rows). Thus, duplicate pointers resulted
   in a crash on program termination. To avoid this, I simply removed the corresponding rows in my test class.

   >> The real solution is to actually utilize a GUI element and simulate the events...

-- Ran into another DND issue that regarding the various multi-column views. Apparently, unless the entire row is selected the QAbstractItemView implementation will not
   remove those rows. How to get around this where we only allow selecting of the primary column cells...

   A) Hijack Qt::CopyAction for this purpose and move the rows afterwards. Semantically wrong
   B) [SOLUTION] Set selectmode to selectrows on the view! This passes the test in the QAbstractItemView.cpp clearOrRemove method and thus removes the selected rows.

      Creates kind of funky visual effect though. Can grab the whole row but it only shows the primary column as selected.

[16 September 2010, Thursday]
-- I think I finally understand the DND approach implemented by the trolls with regard to moving items. It is intended to support multiple models. For example, suppose
   there are two separate views, Va and Vb, that are attached to two different models, Ma and Mb, respectively. If a selected item in Va is dropped into Vb with an action
   of MoveAction, the dropMimeData function of Mb is called with a QMimeData * data corresponding to the selection from Va. Since there are two separate models, and Mb
   has no idea that Ma even exists, there is no mechanism for it to directly perform a move operation. Rather all it can do is create a representation of this data within
   its own model and return true. A true response then signals to Va that the move was successful. Since Va is the controller between Ma and Vb, it then calls removeRows
   to complete the move operation. This makes sense, because only the view knows where the data came from and where it is going.

    I think the trolls did it this way to provide for handling multiple models; however, move operations within the same model can be more tedious to handle - especially
    when dealing with tree structures.

-- SOLUTION to the above problem!

   >> Create a new AdocTreeNode for each node being moved. Thus, we are indeed creating in essence a second copy of this data from wherever it originated; however, since
      we know that there is only model being dealt with here we can do even better. As soon as we return true, the calling item view will remove those selected rows that
      were moved. This potentially is problematic, since we don't want to create a deep copy along with the corresponding database structure. Especially since this could
      be a very large amount of data if ancestral nodes are moved around.

      Thus, we simply transfer all of the children from the nodes being removed to its newly created AdocTreeNode. In essence, moving everything except the selected node
      itself. Then we append our newly created nodes with the transferred children to the new parent. To prevent the removeRows function for the selected nodes from deleting
      the actual database records, we simply set the fkId_ to zero for those selected nodes. This circumvents having to store any duplicate pointers on the tree structure,
      moves the nodes in a lightweight fashion, and does not require any additional tracking data structures.

   >> In other words, allow the view to remove the rows from the source model but strategically perform the move operation before returning true. All children nodes are
      moved manually (calling beginRemoveRows/endRemoveRows to ensure any other connected views are updated) and then prevent any database records associated with these
      nodes from being deleted by setting the fkId_ to zero.

[17 September 2010]
-- Contemplating the optimal mechanism for displaying alignments. Originally, was going to create textures on the fly and use OpenGL; however, rethinking the software raster
   engine. Given the simple nature of alignments - fixed width font and predefined locations - some optimizations just might make this quite feasible.

   Current plan:
   >> Lazily render desired characters into pixmap cache using QPainter / QPainterPath
   >> QImage::Format_ARGB32_Premultiplied format
   >> Cache images in the global QPixmapCache object

[20 September 2010]
-- After some time thinking through the display situation, I think that utilizing the raster engine will probably be more than sufficient for our alignment display purposes:

   http://labs.qt.nokia.com/2010/03/01/insanity-is-shaping-the-same-text-again-and-expecting-a-different-result/

   Quick results (windows and linux use different hardware :\)
   Raster - windows - drawCachedPixmap = 3,500,000+ glyphs per second
   OpenGL - windows - drawCachedPixmap = 20,000,000+ glyphs per second!

   Raster - linux - drawCachedPixmap = ~500,000 glyphs per second
   OpenGL - linux - drawCachedPixmap = 1,700,000 glyphs per second

-- QPixmapCache provides a key based system for caching pixmaps. Could also provide our own pixmap caching mechanism:

                          Column = 10 intensity values
   65 - 65 = A; row -> [0][0 1 2 3 4 5 6 7 8 9]
   66 - 65 = B; row -> [1][...]
   67 - 65 = C; row -> [2][...]
   ...

   To retrieve pixmap:
   Pixmap glyph = cachedGlyph('C', 5);

   Pixmap cachedGlyph(char c, int intensity)
   {
       if (!glyphs[c][intensity])
           glyphs[c][intensity] = generateGlyph(c, intensity);

       return glyphs[c][intensity];
   }

[21 September 2010]
-- How to store MSA data?

   Database -> MSA's are stored in {amino,dna,rna}_msas and their corresponding subseqs in {amino,dna,rna}_msas_subseqs. Only one node is stored in
               the data_tree table for each MSA.

   Upon double-clicking a MSA within the data organizer, the MsaWindow is displayed in all of its glory. The calling code would then load the relevant data from the database
   for the given MSA.

   The MSA would have its own array of sequence data that is loaded once when opened.

-- Not all MSA windows will be equal. Meaning, amino alignments will have very different visualization parameters and options than DNA or RNA sequences. How to work around these
   differences? First step is to identify what is common and what varies.

[22 September 2010]
-- Immediate task list: add transaction support to DbDataSource - done.
-- Add dummy icons for the different types of data tree nodes; original in the design/icons.svg file
   -> Project
   -> Dna
   -> Rna
   -> Amino - used PyMol to render a raytraced Alanine-Glycine peptide fragement
   -> Msa amino
   -> Msa dna
   -> Msa rna

   For alignments, simply used several horizontal lines.

   In pymol, to get a transparent background for ray tracing, use the following command:
   > set ray_opaque_background, off

   Other settings used in rendering:
   Display | Two-sided lighting
   Display | Depth-cue (off)
   Settings | Rendering | Shadows | None

-- Redesigned the folder selection dialog for importing sequences

-- Because of the way flags is implemented and all nodes are virtually independent, DnD currently works and supported for MSA nodes. Yoohoo!

-- Now that alignment import has been implemented and alignment nodes are contained within the data tree, there are some outstanding issues:

   >> Show {amino,dna,rna} aligment nodes in the respective {amino,dna,rna} views [DONE - untested as with many of the specific slice model parameters]
   >> eraseNodes for alignment (downstream: what happens if an alignment is currently being edited?)
   >> Renaming in the data_tree does not rename in target table; however to handle this? This is not only a problem for msas but also seqs and subseqs

[23 September 2010]
-- Erase nodes when it includes a MSA must be handled specially. [DONE]

-- Many times a prepopulated database file is helpful when unit testing a specific class. These are placed under the tests/test_databases folder. To facilitate managing these along
   with their associated unit tests, each database file should be named with the name of the class being tested but in lowercase and words separated by underscores. Filenames should
   end with the db extension. Examples:

   AdocDbDataSource -> adoc_db_data_source.db
   AminoSliceModel -> amino_slice_model.db

   If a single unit test requires multiple files, an arbitrary and informative -suffix should be applied:

   adoc_db_data_source-msaErase.db

   Because these files usually contain test sequence data, it is helpful to build the database itself from AlignShop via importing various files and then simply
   move it to the test_databases folder. It might be useful to revisit these files that were imported during the creation of the database, thus a separate directory with the suffix -files
   should be created and relevant data files placed here. For example:

   AdocDbDataSource [class]
   adoc_db_data_source.db [test database]
   adoc_db_data_source-files/... [location of files used to build this test database]

-- MSA notes from whiteboard:

   o Consider adding tags + notes for every node in the data tree
   o MSA's only need to receive dataChanged signals for Seq level properties from the parent model
   o Do not store MSA subseqs in the data tree; load these in the MSA

-- Need a MSA data object and then views that can attach/detach to this enhanced data store.

[24 September 2010]
-- How to deal with loading/saving MSA data...

-- Sidenote, will store dynamic MSA data such as the information content (logo) and consensus in the database, but will always recompute it on demand rather than relying on this stored
   result. This provides users with ability to use this information from the db, but sidesteps any changes they may make to it.

-- Font thoughts: http://hivelogic.com/articles/top-10-programming-fonts

   Turns out that Qt supports OpenType fonts and that Inconsolata (http://www.levien.com/type/myfonts/inconsolata.html) is just that! It is licensed under the OFL
   http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&item_id=OFL, which explicitly permits using this font in commercial applications.

   Other alternatives: consolas which costs $35 for one type, and $120 for the family (http://www.ascenderfonts.com/font/consolas-family.aspx)
   Droid fonts (Apache license): http://www.ascendercorp.com/pr/2007-11-12/

-- Major class for viewing and manipulating MSA: MsaWindow which will be owned by MainWindow. This class will have the full responsibility of handling MSA related data and be the last
   class to be destroyed. Consequently, it is the master document for all things related to a given MSA. It will have ties to the AdocTreeModel for responding to various changes such
   as Seq level properties and new derived data production (background thread which produces or fetches derived data such as transmembrane regions or secondary structure, etc.)

   >> Need a model class for handling the Subseq annotation data, which will vary depending on the Subseq type: amino, dna, or rna
   >> MsaWindow will contain an AdocDbDataSource member for database interactivity. Specifically, this includes:
      o Loading alignment data. Why loading? it is possible the user will want to revert to the saved state, which requires the load functionality. Thus, it makes sense to put this here
      o Saving alignment data
      o Fetching derived results? e.g. pfam domains, transmembrane regions, etc.
   >> Msa object for actually containing and manipulating the alignment data
   >> Widgets (not sure how granular they should be)
      o Alignment view: specialized blank widget that handles drawing the actual alignment characters (via cached pixmaps); it will also have support for office ruler-like coordinates
                        on the borders - should these be separate widgets?
      o TableView for showing the Subseq annotation data

-- Don't think that the Msa data should be tightly coupled with the subseq annotation data. This would make it difficult to separate should we ever want a lightweight Msa object.

[1 October 2010]
-- More on the the coupling of Msa and subseq annotation. What was I thinking of putting the subseq annotation data inside the Msa class?! It's quite obviuos from the phrase "subseq annotation"
   that any annotation should be at the Subseq level! Hello - this is quite obvious the more I thought about it. Originally, I was going to make a RichMsa class that contained a QList<DataRow>
   annotations_ that directly corresponded with the QList<Subseq *> subseqs_; however, this would be tedious to manage and require shifting things around everytime the row order changed in the Msa.

   The superior solution involves a RichSubseq subclass of Subseq that simply contains a DataRow annotation. This then does not require any code changes to keep the annotation in sync as the
   subseqs are rearranged/inserted/deleted.

-- Currently, a Msa does not own its subseqs. Therefore, need some way of managing these externally. Or rather, change the implementation and make them own their subseqs. I think this is what
   needs to be done.


[6 October 2010]
-- SQLite vacuum = 1-2 s / MB

-- Website: rule of thumb - single machine = SQLite, once multiple machines are involved, probably need client/server setup

-- SQLite space usage observations (see /binf/research/case_studies/sqlite_growth):

   o Updating a table with one integer with the same value does not change the file size
   o Updating a table with one integer with a different value increases the database file size, vacuum reduces the size back to its compact form (as in the first test above)
   o Per the docs, vacuum only works on the main database. It is not possible to vaccum an attached database
   o Same results as 1 and 2 with text field

   >> Conclusion: SQLite updates are smart - they only perform an update and consume space if there is an actual change in the field value

   o Delete in any form does not shrink the file size. This is only achieved with the vacuum command or the auto_vacuum.

[7 October 2010]
-- Only one process may write to the SQLite database at any given time. Thus if a transaction only touches one table via an update/insert/delete, these operations are not permitted anywhere else
   in another transaction until the first transaction has been completed.

[11 October 2010]
-- To abstractly access the function name, use the non-standard __FUNCTION__ macro - works in MSVC and gcc.

-- Better alternative for Qt library: Q_FUNC_INFO

-- Threading notes:

   o QThread is a convenience wrapper for dealing with threads - it does not exist in a separate thread itself
   o Communication across signals and slots is thread safe and all data automatically and transparently handled by Qt
   o Calling slots directly will run immediately/synchronous in the current thread
   o moveToThread for a QObject will change the thread affinity for an object and its children (object cannot be moved
     if it has a parent)
   o "Queued" connections occur across threads; "direct" connections are synchronous function calls that occur immediately
   o Connect the signals before calling start (see: post by Kari, http://labs.qt.nokia.com/2010/06/17/youre-doing-it-wrong/)
   o To call a slot in another thread (with event loop running), use QMetaObject::invokeMethod. For example:

     QMetaObject::invokeMethod(&thread, "quit", Qt::QueuedConnection);

   o Proper use avoids subclassing QThread; rather have separate object for doing the computation and move it into thread. This
     computational object should communicate via signals and slots.
     - To provide interruption, must provide checkpointing (usually boolean flag) and provide for pausing/cancelling.
   o If simply reading data or modifying local instance data, no need for locking (e.g. mutex); however, if modifying shared data, then
     locking constraints must be implemented

   >> Helpful links:
   # http://labs.qt.nokia.com/2010/06/17/youre-doing-it-wrong/
   # http://blog.exys.org/entries/2010/QThread_affinity.html
   # http://stackoverflow.com/questions/3297456/invoke-slot-method-without-connection
   # http://codethis.wordpress.com/2011/04/04/using-qthread-without-subclassing

-- Confused about how to stop a thread when used as an interface. Solution = use quit slot

-- 3 options for building asynchronous action classes:
   1) Synchronous simplye return value method

      class SequenceParser {
          ParseResult parseFile(...)
      }

   2) Asynch message based method

      class AsyncSequenceParser {
          void parseFile(...)
          {
              emit parseBegan(...);
              ...
              emit progress(...);
              ...
              emit parseDone(ParseResult);
          }
      }

   3) Hybrid asynchronous wrapper around #1:

      class WrapSequenceParser {
          SequenceParser p;
          void parseFile(file)
          {
              emie done(p.parseFile(file));
          }
      }

-- Parse structure:
   struct ParsedSequence {
       QString header_;
       bool valid_;
       BioString sequence_;
   }

   struct ParseResult
   {
       QList<ParsedSequence> parsedSequences_;
       DataFormat format_;
       Alphabet alphabet_;
       bool equalLengths_;
       int error_;
       QString filename_;
   }

-- Convo with Phil Hassey: Keep it simple, don't bother worrying about others screwing with the file outside your app. If you have that kind
   of problem, then you can offer them a service contract at $500 / hr :)


[12 October 2010]
-- Restructuring to make database interaction asynchronous (handled by additional thread) and utilize more of an event driven process.

-- Side notes:
   o Signals and slots may be inherited
   o Signals are in fact, protected (http://www.ntcore.com/files/qtrev.htm)
   o Slots may be private, protected, or public
   o Signal and slot may not have the same signature
   o Slots may be virtual
   o Abstract Base Classes that must have all pure virtual functions declared virtual!

[14 October 2010]
-- Import Sequence dialog - add destination to dialog. Something like (instead of separate dialog):

   Destination: Project1 / PAS domains / Aer-type   [Change...]

-- Modus operandii:
   o all annotation data is immediately saved to the database (synchronously updated in memory, async to database)
   o MSA data subseq data saved in one go

[15 October 2010]
-- Currently all errors via the AdocDataSource will be returned as QStrings; however, it might be useful to map different errors (e.g. InvalidConnection, DatabaseError, etc.) to
   different signals to provide a more robust mechanism for dealing with each and every kind of error.

   getDataTree()
   {
       if (connection not established)
       {
           emit dataTreeError(InvalidConnectionError(...));
           return;
       }
       if (SQL error)
       {
           emit dataTreeError(DatabaseError(...));
           return;
       }
       if (MPTT problem)
       {
           emit dataTreeError(InvalidMpttNodeError(...));
           return;
       }
       ...
   }

-- DDL changes to implement:
   o Add tags to seqs and subseqs tables
   o Remove foreign_table from data_tree
   o Add position to the msa join table for subseqs - to carry ordering information

[18 October 2010]
-- Decided to utilize the name, TableModel, for modeling the results of a table, which more or less models that of a database table.
   At some point, it will inherit from QAbstractItemModel and thus provide the underlying framework for use with views; however, this
   is currently not necessary and will be implemented later.

   Initially all columns will be selected by default and no mechanism will be provided for specifying otherwise. Because of the interdependent
   nature of Seqs and subseqs relative to their arrangement on the data tree, these will be specially handled with the subclasses SeqModel,
   and SubseqModel, which are parameterized by alphabet.

-- When registering any kind of metatype variable it is vital to include the MetaObject header!! For about 2 hours I struggled with why registering the global Alphabet enum as a
   metatype would fail with errors like the following:

   > expected constructor, destructor, or type conversion before 'enum'

     /usr/include/qt4/QtCore/qmetatype.h: In static member function 'static int QMetaTypeId2<T>::qt_metatype_id() [with T = Alphabet]':
     /usr/include/qt4/QtCore/qmetatype.h:210:   instantiated from 'int qMetaTypeId(T*) [with T = Alphabet]'
     /usr/include/qt4/QtCore/qvariant.h:571:   instantiated from 'T qvariant_cast(const QVariant&) [with T = Alphabet]'
     TestAdocDbDataSource2.cpp:415:   instantiated from here
     /usr/include/qt4/QtCore/qmetatype.h:200: error: 'qt_metatype_id' is not a member of 'QMetaTypeId<Alphabet>'
     make: *** [TestAdocDbDataSource2.o] Error 1

   o Simply adding #include <QtCore/QMetaType> solved these problems immediately! Argh! What a waste of time.

[20 October 2010]
-- Concerned about the performance impact of utilizing QMetaObject::invokeMethod. On the same token, I'm not sure how else I would decentrally return results to specific requesters.
   Anyways, using a QBENCHMARK block with a QInvokeMethod revealed that it will likely not suffer any performance issues:

   Type               # calls     time      calls / ms
   DirectConnection   425,984     .0012 ms  ~355 million
   QueuedConnection   278,528     .0041 ms  ~68 million

   Conclusion: Direct or Queued (5x slower), it flies! and should not represent a problem.

   Moreover, the proportion of time utilized by invokeMethod's dynamic nature is virtually guaranteed to be magnitudes slower than the I/O operations for requesting data. For instance,
   if I/O = 95% and takes .95 s, and the remaining .05 s is used by invokeMethod. Somehow optimizing this to direct connections gives a 5x speedup making .1 s happen in .02 s. Thus, the
   time savings is .04 s or 4%. The fact is that I/O is probably responsible for 99.99% of the time.

   >> Bigger question: is the design good? Ultimately all data must be passed via signals and slots. Therefore, any task that requires multiple different types of data must utilize
                       some form of signal multiplexing.

-- By convention, all database tables must have a primary key field named id

-- QMetaObject::invokeMethod can be used by any method to call any slot on any object the calling code has access to. The way to truly make such connections private is to hide them
   inside some private class. While that works it is overkill for our purposes and involves extra implementation details. For now, all private slots by convention are prefixed by
   double underscores. This is a note to developers that they may call these methods, but be aware that they are intended for private use only.

[25 October 2010]
-- Having to seriously rewire the SliceModel class... :| Because its current implementation and many other facets represents a significant chunk of work that I may want to revisit,
   I have created a tagged version before the AdocDataSource revampage including the current SliceModel plan. Thus, it should be safe to tweak at this point. In any event, should I
   want to revisit this code - it is at:

   REVISION 146!! Or possibly 147

[29 Oct 2010]
-- Found a strange issue today while working with releasing a database file lock.

   Context: Windows vista, SQLite3, QSqlQuery and QSqlDatabase

        QString testCreateDbFile = "test-database.db";
        {
            QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", "test-create");
            db.setDatabaseName(testCreateDbFile);
            QVERIFY(db.open());
            QCOMPARE(db.tables().count(), 2);
            QVERIFY(db.tables().contains("astrings"));
            QVERIFY(db.tables().contains("data_tree"));

            QSqlQuery query = db.exec("SELECT label, fk_id, lft, rgt FROM data_tree");
            QVERIFY(query.next());
            QCOMPARE(query.value(0).toString(), QString("Root"));
            QCOMPARE(query.value(1).toInt(), 10);
            QCOMPARE(query.value(2).toInt(), 20);
            QCOMPARE(query.value(3).toInt(), 30);

            query = db.exec("SELECT sequence FROM astrings");
            QVERIFY(query.next());
            QCOMPARE(query.value(0).toString(), QString("ABC"));

            db.close();
        }
        QSqlDatabase::removeDatabase("test-create");

        QFile::remove(testCreateDbFile) <-- FAILS!

   >> I would have thought the above code would have released testCreateDbFile for removal via QFile::remove() or other means;
      however, on windows it appears to remain locked even after the database has been closed and removed.

      Workarounds:
      1) Remove the db.close() call - db will go out of scope
      2) Put QSqlQuery query in a separate code block
      3) query.clear()

      Thus, it appears that db.close() somehow leaves the query object in a state that retains a file lock. I presume that by remvoing
      the db.close() function, query is freed first and then the db object. Interesting...

[17 November 2010]
-- I was struggling with how to implement the data() method of specific models (e.g. AminoSliceModel, DnaSliceModel, etc), when the user
   dynamically defines the columns to use. Without somehow linking these two together, it is virtually impossible. In other words, suppose
   I want to return a monospace font for the sequence column of data, yet how does the model class know which column this is? The solution:
   encapsulate what varies. Make a specific class that specifies the field names and columns and have the TableModel use these:

   // AminoSliceModel.h
   class AminoSliceModel : public SubseqSliceModel
   {
   public:
       static const QStringList subseqFields_;
       static const QStringList seqFields_;
       ...
   };

   // AminoSliceModel.cpp
   QStringList AminoSliceModel::subseqFields_(QStringList() << "id" << "amino_seq_id" << "start" << ...);
   const int kSubseqIdColumn = 0;
   const int kSubseqAminoSeqIdColumn = 1;
   ...
   QStringList AminoSliceModel::seqFields_(QStringList() << "id" << "astring_id" << "source" << ...);

   QVariant AminoSliceModel::data(...)
   {
       switch (index.column())
       {
       case kSubseqIdColumn:
            ...
       }
   }

   // other.cpp
   TableModel aminoSubseqs;
   TableModel aminoSeqs;

   aminoSubseqs.setSource(dataSource, constants::kTableAminoSubseqs, AminoSliceModel::subseqFields_);
   aminoSeqs.setSource(dataSource, constants::kTableAminoSeqs, AminoSliceModel::seqFields_);

   AminoSliceModel aminoSliceModel;
   aminoSliceModel.setSourceTable(eAminoAlphabet, aminoSubseqs, aminoSeqs);

[24 November 2010]
-- MsaSubseqModel - what happens when the Subseq or Seq table is reset/cleared? Need to temporarily clear the relevant subseq and/or seq cells (if seqTable is defined),
   request data from source, and restore when data has been loaded. This is handily done because dataChanged takes a (top, left) -> (bottom, right) range.

   register subseq table loadDone / loadError
   register seq table loadDone / loadError

   Add private members subseq_load_tag, seq_load_tag

   Subseq table reset ->
      subseqTable->load(msa->subseq_ids, tag)
      rows_ = 0
      reset()

   Subseq data changed ->
      y->subseqDataChanged - throw assertion if start/stop field (ignore in release mode)
      emit appropriate dataChanged

   Seq table reset ->
      @seq_ids = distinct(seq_ids from @subseqs)
      seqTable->load(msa->subseq_ids, tag)
      rows_ = 0
      reset()

   Seq data changed ->
      y->seqDataChanged - emit appropriate dataChanged

-- MsaSubseqModel: first three fields are always the subseq id, start, stop


[30 November 2010]
 - User may want precision (mouse drag) or loose parameters.
  - Default to the first 1000 chars.
  - Amplicon length default: 1000, allow 50-N
  - Primer length default: 17, allow 10 - 120
  - TN default: 50-60, allow 35-80
  - Restriction enzyme: free-text or selection
    - Prevent accidental modification of selected enzymes
    - Allow clearing, manual typing

 - Need to be able to display reverse-compliment right below a sequence.
   - Toggle visibility of reverse-compliment
   - Display in blocks of 10 chars

 - Search reverse compliment in data organizer...

 - Primer selection screen, what can we do to help user make decision?
   - Results show, F/R, TM-notation, sequence, score
   - Select a result, hilights the area in the sequence

- Luke follow up w/Paul: Need to ask Paul for: Titles, labels, warning messages, and help text (minimized form).

- Chris follow up w/Eowyn - What kind of standard notation is there for denoting primer-pairs visually or via characters?

[7 Dec 2010]
-- Moving rows in QList is inconsistent with moveRows parameters associated with the QAbstractItemModel. Specifically, this only
   occurs when moving earlier rows to later positions within the array.

   Given the array: [0, 1, 2, 3, 4, 5]

   QList.move(2, 5) -> [0, 1, 3, 4, 5, 2]
   QList.move(2, 0) -> [2, 0, 1, 3, 4, 5]

   QAbstractIemModel.moveRows(QModelIndex(), 2, 2, QModelIndex(), 5) -> [0, 1, 3, 4, 2, 5]
   QAbstractIemModel inserts before the target row, not at the target row. In other words,

   Where x < y:
   >> QList.move(x, y) == QAbstractItemModel.moveRows(QModelIndex, x, x, QModelIndex, y+1)
   Where x > y:
   >> QList.move(x, y) == QAbstractItemModel.moveRows(QModelIndex, x, x, QModelIndex, y)

[9 Dec 2010]
-- New testing issue. Due to the way that the QFETCH macro is defined, it is not possible to use it with QHash or QPair
   or any other templated structure that has a comma. For instance,

   QFETCH(QHash<int, int>, lookup);
   QFETCH(QPair<QString, QString>, names);

   will both fail, because there is a comma in the first argument to QFETCH, which when the macro is applied makes it
   look to the compiler as though there are 3 arguments. The solution around this is to typedef the necessary data
   structure:

   typedef QHash<int, int> LookupHash;
   QFETCH(LookupHash, lookup);

   // OR
   typedef QPair<QString, QString> NamePair;
   QFETCH(NamePair, names);

-- Another vital point when dealing with "row" test data is that the names provided in quotes via the addColumn method
   must correspond to the variable names used by QFETCH. For instance:

   // in _data() function
   QTest::addColumn<QString>("VARIABLE_NAME");

   // in testing function
   QFETCH(QString, VARIABLE_NAME);

   Anyways, VARIABLE_NAME must be the same in both methods for it to work properly!

[4 Jan 2010]
-- Performance of drawing MSA data on screen:

   o Naive, brute force method: simply use QPainter to drawText = very slow, inefficient
   o On-demand pixmap creation and caching per character = reasonably fast; although too slow on windows
   o Hybrid: maintain and draw larger version pixmap(s) that collectively maintain multiple rendered characters
     >> Single pixmap that gets updated when msa changes; downside = with huge alignments could take significant time
        to build as well as utilizing tons of memory
     >> Pixmap per column: works well for inserting/removing gaps; less efficiently with sliding operations
     >> Pixmap per row: works well for sliding operations; less efficiently for inserting/removing gaps
        ** Possibly better choice than columns because most often, the alignment length will be << number of sequences
     >> Pixmap tiles of arbitrary size: perhaps the most memory efficient; however, probably most difficult to implement
     ** Optimization: rather than build all pixmaps at once, maintain those that have been visualized and add as user
        pans, and remove if collective memory threshold is exceeded.
     ** Con: When zoomed in, pixmaps will be massive! Either limit the zoom, and/or dynamically size the rendered columns
        relative to the viewport. OR: switch over to direct rendering once the zoom exceeds a certain threshold.
   o OpenGL texture based approach = fast, but significantly more work to implement

   Just performed a quick test with row-based pixmap rendering and it dramatically improved performance - so much so
   that even on windows the movement is quite speedy with 25-50 rows at 100%, 200 rows at both 25% and 200%! Swank!

   Now, we have a problem that retaining all these rows in RAM or VRAM will occupy too much space for all but the
   smallest alignments. To circumvent this problem, probably should keep a prerendered block that covers the viewport
   + some percentage of the invisible portion. Rendering can be pushed to separate worker thread. This approach would
   then provide most flexible and rapid means of displaying tons of little images.

[5 Jan 2010]
-- Not sure how to offload rendering to worker thread because all data used in rendering process is contained within
   GUI thread. Only option would be to pass all rendering information to the thread. For instance, a vector of the
   following:

   { row: 34,
     column: 100
     [ A, fg color, bg color],
     [ B, fg color, bg color],
     [ C, fg color, bg color],
     [ D, fg color, bg color]  },
   { row: 34,
     column: 100
     [ A, fg color, bg color],
     [ B, fg color, bg color],
     [ C, fg color, bg color],
     [ D, fg color, bg color]  }

   Perhaps this would be the best course because computing this would be relatively quick compared to the actual rendering
   and image resizing operations.

-- Perhaps the GUI thread is able to simply capable of rendering on the fly.

   Test: Render only those characters that will be partially visible on the screen and update the source image data in
         response to resize events. Because image manipulation is better done with QImage, but display is better with
         QPixmap, maintain an array of QImages and QPixmaps. When done manipulating the QImage, simply convert it to its
         cognate QPixmap, which are utilized in the paint event.
   OS: Linux
   Result: Very responsive when shrinking the window, noticeable lag when expanding the window

   Hypothesis: Converting back/forth to pixmaps is slower than simply using QImages.
   Test: use only QImages
   Result: Worse performance! Much more noticeable lag.
   Conclusion: From looking at the source code and corroborated by an online article, all images are converted to pixmaps
               and then drawPixmap - so instead of caching this result, it is actually doing the conversion every update!
               No wonder its slower.

   Hypothesis: Using QImage is unnecessary since QPainter can work directly on pixmaps and there is no gain to QImage.
   Test: Use only QPixmaps
   Result: Tons faster! Probably would work just fine for our purposes. Great for both windows and Linux

   More results: when scaling the font down and in turn showing more sequences, the update slows noticeably when there
   are large changes to be displayed. Anything pre-rendered runs quickly enough, but new content does not appear that
   quickly.

-- Guess: final result will be one of two options:

   1) Use OpenGL and textures

   2) Utilize a worker thread that maintains a list of QImages and updates these in response to user events, returns
      these results, which are then stored in main thread as pixmaps.

-- Ultimately, OpenGL completely dominates. I suppose I will have to go this route. Ugh.

-- Contacted Tomasz Stachowiak and received permission to utilize his Hybrid code for our project - woohoo!
   Only issue with this is potential computers without OpenGL support. Would hate to have to support both though. Maybe
   we can make it a requirement. Perhaps the percentage without openGL support is so low that this is easily excusable...

-- QAbstractScrollArea with a grid layout and the opengl widget view in the bottom right. Or simply have OpenGL do it all.

[10 January 2011]
-- Tried QGraphicsView - dog slow to initialize and really slow when rendering. No way.

-- OpenGL is the way we will move forward. After disabling some unneeded states, speed picked up similar to that of the
   old results. Yehaw.

-- Proposal for MSA drawing:

   o Interface widget:

     class MsaView : QWidget   [ software rendering ]
     {
     public:
         void setMsa(const Msa *msa);

         void drawEverything(const QPainter &painter)
         {
             drawMsa(getMsaRect(), painter);
             drawMarkers(painter);
         }

     protected:
         virtual void drawMsa(const QRect &rect, const QPainter &painter) = 0;
         virtual void drawMarkers(const QPainter *painter) = 0;

         virtual void paintEvent(QPaintEvent *event)
         {
              QPainter painter(this);
              drawEverything(&painter);
         }
     };

     class GLMsaView : public MsaView
     {
     public:
         void paintGL() // Only exception we have to do to get it working with OpenGL
         {
             // Utilize a dumb painter
             drawEverything(QPainter());
         }

         void drawMsa(const QRect &rect, const QPainter &/* painter */)
         {
             // Do openGL crap; ignore painter, should be invalid
         }
     };

[12 January 2011]
-- Going to use the QAbstractScrollArea widget for the MsaView. In the final implementation would like to have special
   axii on borders of view to delinate such things as the current position, selection, sequence coordinates, etc.

   QAbstractScrollArea provides mechanism for defining margins in which one can add these specialized "displays";
   however, with the default implementation, the scrollbars still extend the full height/width of the entire
   QAbstractScrollArea. It is desirable to have these limited to the actual alignment view region. To accomplish this,
   it is necessary to override the resizeEvent, and then simply resize the scrollbars to match the specified margin:

    {
        // ...
        setViewportMargins(40, 10, 20, 1);
    }

    void resizeEvent(QResizeEvent *e)
    {
        QAbstractScrollArea::resizeEvent(e);

        QRect vRect = verticalScrollBar()->geometry();
        QRect hRect = horizontalScrollBar()->geometry();

        vRect.setTop(10);
        vRect.setHeight(viewport()->height());
        verticalScrollBar()->setGeometry(vRect);

        hRect.setLeft(40);
        hRect.setWidth(viewport()->width());
        horizontalScrollBar()->setGeometry(hRect);
    }

   http://kernelcoder.wordpress.com/2010/08/25/how-to-insert-ruler-scale-type-widget-into-a-qabstractscrollarea-type-widget/
   To arrange widgets in these areas, use a GridLayout:
   // In QAbstractScrollArea constructor:
    {
        QGridLayout *gridLayout = new QGridLayout();
        gridLayout->setSpacing(0);
        gridLayout->setMargin(0);

        QWidget *fake = new QWidget();
        fake->setFixedSize(40, 10);
        gridLayout->addWidget(fake, 0, 0);

        Spacer *horiz = new Spacer(QSize(100, 10));
        Spacer *vert = new Spacer(QSize(40, 200));

        gridLayout->addWidget(horiz, 0, 1);
        gridLayout->addWidget(vert, 1, 0);
        gridLayout->addWidget(this->viewport(), 1, 1);

        this->setLayout(gridLayout);
    }

[14 January 2011]
-- Working code for setting up live clustal colors for msa:

    BioSymbolGroup clustalSymbols;
    clustalSymbols << BioSymbol('%', "WLVIMAFCYHP", .6)
                   << BioSymbol('#', "WLVIMAFCYHP", .8)
                   << BioSymbol('-', "DE", .5)
                   << BioSymbol('+', "KR", .6)
                   << BioSymbol('g', "G", .5)
                   << BioSymbol('n', "N", .5)
                   << BioSymbol('q', "QE", .5)
                   << BioSymbol('p', "P", .5)
                   << BioSymbol('t', "ST", .5)
                   << BioSymbol('A', "A", .85)
                   << BioSymbol('C', "C", .85)
                   << BioSymbol('D', "D", .85)
                   << BioSymbol('E', "E", .85)
                   << BioSymbol('F', "F", .85)
                   << BioSymbol('G', "G", .85)
                   << BioSymbol('H', "H", .85)
                   << BioSymbol('I', "I", .85)
                   << BioSymbol('K', "K", .85)
                   << BioSymbol('L', "L", .85)
                   << BioSymbol('M', "M", .85)
                   << BioSymbol('N', "N", .85)
                   << BioSymbol('P', "P", .85)
                   << BioSymbol('Q', "Q", .85)
                   << BioSymbol('R', "R", .85)
                   << BioSymbol('S', "S", .85)
                   << BioSymbol('T', "T", .85)
                   << BioSymbol('V', "V", .85)
                   << BioSymbol('W', "W", .85)
                   << BioSymbol('Y', "Y", .85);

    QColor red(.9 * 255, .2 * 255, .1 * 255);
    QColor blue(.1 * 255, .5 * 255, .9 * 255);
    QColor green(.1 * 255, .8 * 255, .1 * 255);
    QColor cyan(.1 * 255, .7 * 255, .7 * 255);
    QColor pink(.9 * 255, .5 * 255, .5 * 255);
    QColor magenta(.8 * 255, .3 * 255, .8 * 255);
    QColor yellow(.8 * 255, .8 * 255, 0);
    QColor orange(.9 * 255, .6 * 255, .3 * 255);

    SymbolColorScheme clustalColorScheme;
    clustalColorScheme.setCharTextColorStyle('G', TextColorStyle(Qt::black, orange));
    clustalColorScheme.setCharTextColorStyle('P', TextColorStyle(Qt::black, yellow));
    clustalColorScheme.setCharSymbolsColorStyle('T', "tST%#", TextColorStyle(Qt::black, green));
    clustalColorScheme.setCharSymbolsColorStyle('S', "tST#", TextColorStyle(Qt::black, green));
    clustalColorScheme.setCharSymbolsColorStyle('N', "nND", TextColorStyle(Qt::black, green));
    clustalColorScheme.setCharSymbolsColorStyle('Q', "qQE+KR", TextColorStyle(Qt::black, green));

    clustalColorScheme.setCharSymbolsColorStyle('W', "%#ACFHILMVWYPp", TextColorStyle(Qt::black, blue));
    clustalColorScheme.setCharSymbolsColorStyle('L', "%#ACFHILMVWYPp", TextColorStyle(Qt::black, blue));
    clustalColorScheme.setCharSymbolsColorStyle('V', "%#ACFHILMVWYPp", TextColorStyle(Qt::black, blue));
    clustalColorScheme.setCharSymbolsColorStyle('I', "%#ACFHILMVWYPp", TextColorStyle(Qt::black, blue));
    clustalColorScheme.setCharSymbolsColorStyle('M', "%#ACFHILMVWYPp", TextColorStyle(Qt::black, blue));
    clustalColorScheme.setCharSymbolsColorStyle('A', "%#ACFHILMVWYPpTSsG", TextColorStyle(Qt::black, blue));
    clustalColorScheme.setCharSymbolsColorStyle('F', "%#ACFHILMVWYPp", TextColorStyle(Qt::black, blue));
    clustalColorScheme.setCharSymbolsColorStyle('C', "%#ACFHILMVWYPp", TextColorStyle(Qt::black, blue));
    clustalColorScheme.setCharSymbolsColorStyle('C', "C", TextColorStyle(Qt::black, pink));
    clustalColorScheme.setCharSymbolsColorStyle('H', "%#ACFHILMVWYPp", TextColorStyle(Qt::black, cyan));
    clustalColorScheme.setCharSymbolsColorStyle('Y', "%#ACFHILMVWYPp", TextColorStyle(Qt::black, cyan));
    clustalColorScheme.setCharSymbolsColorStyle('E', "-DEqQ", TextColorStyle(Qt::black, magenta));
    clustalColorScheme.setCharSymbolsColorStyle('D', "-DEnN", TextColorStyle(Qt::black, magenta));
    clustalColorScheme.setCharSymbolsColorStyle('K', "+KRQ", TextColorStyle(Qt::black, red));
    clustalColorScheme.setCharSymbolsColorStyle('R', "+KRQ", TextColorStyle(Qt::black, red));

    liveMsaCharCountDistribution_ = new LiveMsaCharCountDistribution(msa_, this);
    liveSymbolString_ = new LiveSymbolString(liveMsaCharCountDistribution_, clustalSymbols, this);
    SymbolColorProvider *symbolColorProvider = new SymbolColorProvider(liveSymbolString_, clustalColorScheme);

[18 January 2011]
-- Need to investigate how well Subseq will/can handle repeats :\

-- Found out it is quite easily possible to render all painter output to an SVG file using the QSvgGenerator class!
   Only takes a couple of lines of code. Very swank! Has been implemented for a few years now:

   http://zrusin.blogspot.com/2007/01/generating-svgs-with-qt.html

[19 January 2011]
-- To simulate/test resize events it is possible to simply adjust the geometry and then call the resizeEvent method
   ourselves (possible when testing because we are a friend class).

[25 January 2011]
-- To stream a custom data type, the following is necessary:
   (http://wiki.forum.nokia.com/index.php/Saving_custom_structures_and_classes_to_QSettings)

   o Define the operator<< and operator>> methods, optionally making them friend functions to ease access of private
     member data.

   class Issue
   {
   private:
       int number_;

       friend QDataStream &operator<<(QDataStream &stream, const Issue &issue);
       friend QDataStream &operator>>(QDataStream &stream, Issue &issue);
   }
   Q_DECLARE_METATYPE(Issue)

   QDataStream &operator<<(QDataStream &stream, const Issue &issue)
   {
       stream << (qint32)issue;
       return stream;
   }

   QDataStream &operator>>(QDataStream &stream, Issue &issue)
   {
       qint32 number;
       stream >> number;
       issue.number_ = number;
       return stream;
   }

   o To utilize these as QVariants, it is necessary to register them:

     qRegisterMetaTypeStreamOperators<Issue>("Issue");

   o and use special functions to marshal them around:

     // Convert to QVariant
     QVariant var = qVariantFromValue(issue);

     // Convert from QVariant
     Issue issue = var.value<Issue>();

[26 January 2011]
-- To add an application font, do the following:

   int fontId = QFontDatabase::addApplicationFont(<filename>);
   if (fontId != -1)
   {
       // Get the font:
       QStringList families = QFontDatabase::families(fontId);
       QFont(families.first());
   }

-- Poked around for some free, usable monospace fonts. Turns out there are a few good ones with very open licensing terms. Any font with the
   OFL or Open Font License will work just fine. Namely, the good ones that I have found are:

   Bistream Vera Sans Mono
   Inconsolata
   Cousine font (source: google, http://code.google.com/webfonts/family?family=Cousine&subset=latin)
   Possibly Anonymous Pro

   Source: http://www.thefreecountry.com/programming/programmers-fonts.shtml
   Source: http://code.google.com/webfonts

-- Good link on font anatomy: http://labs.qt.nokia.com/2008/08/28/font-anatomy/

[27 January 2011]
-- Thinking through the zoom mechanism process. First off, pixel-perfect zoom'ing is only possible with full screen
   updates or at least updates that are anchored at the top-left.

[31 January 2011]
-- At the lowest level, it is desirable to utilize a QPainter for all drawing operations because this makes it possible
   to save the result to any number of output devices (e.g. image file, Svg, printer, etc). Currently, text drawing is
   isolated in a FontCharPixmapProvider which forces the output to be a Pixmap and constrains the output options. Thus,
   the new text rendering class structure will be as follows:

   // Virtual base class with core interface methods for rendering text.
   class TextRenderer
   {
   public:
       //! Utilizes only painter operations
       // - Draws only foreground on transparent background
       virtual void drawChar(QPointF point, const QChar ch, const QColor &color, QPainter *painter);
       virtual void drawChar(QPointF point, const QChar ch, const TextColorStyle &textColorStyle, QPainter *painter);
       void setFont(const QFont &font);
       void setScale(qreal scale);

   protected:
       virtual void clearCache()
       {}
   };

   // Saves cached QImage renderings of TextRenderer
   class ImageTextRenderer
   {
   public:
       virtual void drawChar(QPointF point, const QChar ch, const &TextColorStyle textColorStyle, QPainter *painter)
       {
           if (!cached)
           {
                // Insert into the cache
                cachedGlyphs_.insert(glyphKey(ch, textColorStyle), renderChar(ch, textColorStyle));
           }

           painter->drawImage(point, cachedGlyphs_.value(glyphKey(...)));
       }

   protected:
       QImage renderChar(const QChar ch, const QColor &color);
       QImage renderChar(const QChar ch, const TextColorStyle &textColorStyle)
       {
           QImage image(QSize(static_cast<int>(ceil(width(character))), static_cast<int>(ceil(height()))), QImage::Format_ARGB32_Premultiplied);
           QPainter p(&image);
           TextRenderer::drawChar(QPointF(0, 0), ch, textColorStyle, &p);
           p.end();

           return image;
       }

       virtual void clearCache()
       {
           cachedGlyphs_.clear();
       }

   private:
       QHash<QString, QImage> cachedGlyphs_;
   };

   // Saves cached QPixmap renderings of TextRenderer
   class PixmapTextRenderer : public ImageTextRenderer
   {
   public:
       virtual void drawChar(QPointF point, const QChar ch, const &TextColorStyle textColorStyle, QPainter *painter)
       {
           QString key = glyphKey(ch, textColorStyle);
           if (!cachedGlyphs_.contains(key))
               cachedGlyphs_.insert(key, QPixmap::fromImage(ImageTextRenderer::renderChar(ch, textColorStyle)));
           return cachedGlyphs_.value(key);
       }

   protected:
       virtual void clearCache()
       {
           cachedGlyphs_.clear();
       }
   private:
       QHash<QString, QPixmap> cachedGlyphs_;
   }

-- AbstractMsaView will contain a TextRenderer instance for output renderings.

-- NativeMsaView will contain a PixmapTextRenderer instance to be used for all its relevant text rendering
   GlMsaView will contain a ImageTextRenderer for capturing the necessary data to push to a texture

[1 Feb 2011]
-- Learned a new cool trick about virtual signals. Why make a signal virtual? So that subclasses can respond to this
   signal before any other connected classes. In my case, I need to clear an image cache in response to a signal defined
   in the base class - before any other connected classes may respond to this signal. The solution: a virtual signal.

   class Base
   {
   Q_SIGNALS:
       virtual void fontChanged();
   }

   class Derived : public Base
   {
   protected:
       virtual void fontChanged()
       {
            // Do interesting things (e.g. clear a cache)

            // Make sure the base class is called to emit the signal
            Base::fontChanged();
       }
   }

   A less-intrusive alternative would be to utilize Qt's signal/slot mechanism and connect the appropriate signals to
   the right slots in the derived class constructor:

   class Derived : public Base
   {
   public:
       Derived(QObject *parent = 0) : Base(parent)
       {
           connect(this, SIGNAL(fontChanged()), SLOT(clearCache()));
       }
   private slots:
       void clearCache()
       {
           // ...
       }
   }

   This latter approach is probably the better way because it adheres to the API and depends less on an undocumented
   feature :) One downside is testing - a signal on a base class will appear connected on a derived class.

-- Wasted about 20 minutes trying to figure out why fontmetrics would crash my testing. Turns out that FontMetrics
   classes require a QApplication instance. Thus, I had to change:

   QTEST_APPLESS_MAIN(TestTextImageRenderer)

   to:

   QTEST_MAIN(TestTextImageRenderer)

[7 February 2011]
-- Now use QPainterPath and TextLayouts to draw characters. Huge optimization.

[8 February 2011]
-- There are two major prongs to rendering alignments: software-driven, native views and hardware-accelerated, OpenGL
   views. Both are essential - the software because all rendering to image files must be done via QPainter plus it is
   easier to implement. Hardware because this provides superior performance alongside unlimited zoom. Software will be
   limited to rounded zoom.

   View classes: AbstractMsaView
                 |--- NativeMsaView
                 |--- GlMsaView

   Helper classes: TextRenderer
                   CharMetrics - provides integral specific rendering positions (realtime software rendering)
                   CharMetricsF - provides floating point rendering precision (realtime hardware rendering and discrete
                                  software rendering to image files)

-- The most ideal mechanism for rendering with software is the single pixmap method. The naive and all other brute force
   methods are either too slow or jerky, respectively.

-- All rendering to image files is done in software and without any zoom effect - only the current font.

-- To add an application font (also with OS specific instructions):

    int id = -1;
    if (id != -1)
    {
        qDebug() << "Got it";
        qDebug() << QFontDatabase::applicationFontFamilies(id);
        ui_->alignmentView->setFont(QFont(QFontDatabase::applicationFontFamilies(id).first(), 18));
    }
    else
    {
#ifdef Q_OS_WIN32
    ui_->alignmentView->setFont(QFont("Courier New", 12));
#else
    ui_->alignmentView->setFont(QFont("monospace", 12));
#endif
    }

[9 February 2011]
-- Did some research on cross-platform installers. Bitrock appears to be the best; however, it is also costly. Would
   like to avoid if possible.

   Open-source options:
   1) Install Jammer - probably would work fine, except that it does not support MacOS
   2) IzPack - very cross-platform via java; seems to have a good feature set.

   Learned that InstallAnywhere (another commercial installer) accomplishes the cross-platform install via java as well.
   If a professional installer can require Java, then we can too for free!

   My problem, I do not want user's to have to install a JRE to install my program. Ideally, it would use the native VM
   if one is present, and if not then use a temporary JRE packaged with my application and remove the JRE after
   installation (what about uninstall?).

   Unfortunately, IzPack does not have a bundled JRE option. Once person indicated that they used launch4j to wrap a
   temporary JRE for the install process. I guess it should be left for uninstallation purposes. Another option in this
   vein is JSmooth (windows only I think).

   IzPack has a native launcher that is cross-platform and if no VM is found, prompts the user to install one from a
   variety of options. Eh... not so good.

[10 February 2011]
-- Quick way for checking if a double is equal within a certain level of precision:

    if (fabs(first - second) < epsilon)
        return true;

    fabs(10.333 - 10.3333) < .001 --> false
    fabs(10.333 - 10.3333) < .0001 --> false
    fabs(10.333 - 10.3333) < .00001 --> true

-- QDoubleSpinBox is a tricky beast to master. Specifically, I was after a percentage spin box that could

[12 February 2011]
-- Integral coordinates (pixels):
   block width = 10, then valid range = 0-9. Thus the first block would be from 0-9, the next from 10-19, and so forth

   Fractional coordinates (pixels):
   block width = 10.; first block = 0. -> < 10; second block = 10 -> < 20;
     If requesting block from position, the above rules apply: 0 -> 0, 9.99 -> 0, 10 -> 1
     If requesting a rectangle, then the right most value must partially exceed 10 to return the second most block. Thus,
       (0) -> (9.99) = block 0
       (0) -> (10.) = block 0
       (0) -> (10.00001) = block 0 and 1

   This logic is needed because if requesting fractional coordinates for a block 0 will return (0, 0) -> (block width, block height). Thus,
   to make the reverse true it is necessary that the bottomright point in a rectangle request be treated differently than the topleft point.
   In other words, for fractional coordinates:

   block 0 = (0, 0) -> (block width, block height) AND
   (0, 0) -> (block width, block height) = block 0

   For integral coordinates, it is slightly different:

   block 0 = (0, 0) -> (block width - 1, block height - 1) and vice versa.

-- Msa space may be integral and fractional
-- Canvas space is in pixels and so is the view space.

[16 February 2011]
-- Why all the issues? To make the above work as expected, the following is necessary:

   QRectF input;
   ASSERT(input.width() > 0)

   int msaLeft = 1 + input.left() / charWidth();
   int msaRight = msaLeft + ceil(input.width() / charWidth()) - 1;

[18 Feburary 2011]
-- Yesterday completed the accurate, pure floating point representation of PointRectMapperPrivate and its incorporation
   into the core AlignShop code. Works beautifully!

-- For a long time, I have had issues with QByteArray and walking its ASCII contents using const char pointer. It would
   invariably crash whenever I tried to access the pointer. Sometimes it would show the contents when printed or a
   garbled portion of it. Here is what I usually did:

   QString sourceString;
   const char *x = sourceString.toAscii().constData();
   // Access x = CRASH!!

   The docs claim for the constData() method: "The pointer remains valid as long as the byte array isn't reallocated or
   destroyed." What I just now realized is that the QByteArray returned from the toAscii() method is a temporary that
   is no longer visibly seen or accessible after the constData() method is called. Thus, it is in all likelihood
   destroyed after the statement finishes. Upon destruction the constData pointer is no longer valid and the program
   crashes. Hence, the fix is to preserve the source QByteArray until after using the pointer is finished:

   QByteArray byteArray = sourceString.toAscii();
   const char *x = byteArray.constData();
   // Do stuff with x

-- Selection --

   A selection is defined as two points within the same msa space that together define a contiguous arbitrary grid. A
   selection has a well-defined starting point and a well-defined ending point. It is 1-based. A selection may only be
   made while in edit mode. It is visible in all modes.

[28 Feb - 4 Mar 2011]
-- Implemented and built a replacement for PSI-PRED. See the /binf/research/nn-sec notes.

   Bugfix and optimization for PSI-PRED: http://www.csc.fi/english/research/sciences/bioscience/programs/blast/optimized_psiblast

   For information on this, see the publication:
   "Code Optimization of the Subroutine to Remove Near Identical Matches in the Sequence Database Homology Search Tool
    PSI-BLAST" J. Comp Biol, 2009

[9 March 2011]
-- Learned how to spawn external processes from within alignshop - quite easy!

   QProcess *process_;

   process_ = new QProcess(parent);
   // Connect any desired signals...
   // connect(process_, SIGNAL(finished(int)), SLOT(onFinished(int))
   // ...

   // Setup arguments
   QStringList arguments;
   arguments << "-a" << "4" << "-d" << "/binf/db/seq/uniref50.segcoil";

   // Run the process
   process_->start("/binf/bin/blastpgp", arguments);

   // To write to the process:
   process_->write("MVLSEGEWQLVLHVWAKVEADVAGHGQDILIRLFKSHPETLEKFDRVKHLKT...");
   process_->closeWriteChannel();

-- Also learned about the utility of using FLEX and BISON for parsing purposes.

   -- Flex Your Lexical Analysis Muscles
   http://www.codeguru.com/cpp/cpp/algorithms/strings/article.php/c12717/
   -- Classic Parsing with Flex and Bison
   http://www.codeguru.com/csharp/.net/net_general/patterns/article.php/c12805

   Qt integration:
   http://www.qtcentre.org/threads/3557-Flex-Bison-and-qmake
   -- How to use flex and bison with qmake (my own way)
   http://www.freehackers.org/thomas/2009/11/22/how-to-use-flex-and-bison-with-qmake-my-own-way/

   o In general, flex (or lex) tokenizes an input stream and bison (or yacc) parses and reacts to the tokens
   o Example of using Flex to take average length of FASTA sequences:
     http://biostar.stackexchange.com/questions/1759/code-golf-mean-length-of-fasta-sequences

[10 Mar 2011]
-- Official Recommendations on Biochemical & Organic Nomenclature, Symbols & Terminology etc:
   http://www.chem.qmul.ac.uk/iubmb/

   http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html
   DNA
   Table 1. Summary of single-letter code recommendations
   Symbol	Meaning             Origin of designation
   G        G                   Guanine
   A        A                   Adenine
   T        T                   Thymine
   C        C                   Cytosine
   R        G or A              puRine
   Y        T or C              pYrimidine
   M        A or C              aMino
   K        G or T              Keto
   S        G or C              Strong interaction (3 H bonds)
   W        A or T              Weak interaction (2 H bonds)
   H        A or C or T         not-G, H follows G in the alphabet
   B        G or T or C         not-A, B follows A
   V        G or C or A         not-T (not-U), V follows U
   D        G or A or T         not-C, D follows C
   N        G or A or T or C	aNy

   Table 2. Definition of complementary symbols

    Symbol	    A	B	C	D	G	H	K	M	S	T	V	W	N
    Complement	T	V	G	H	C	D	M	K	S*	A	B	W*	N*

-- Use BioPython as reference for working with sequence data :) Has very liberal license

[23 March 2011]
-- Finished preliminary view implementation of extending and trimming Msas in AbstractMsaView. Two major issues are
   outstanding:
   1) Coloring is not properly updated [applies only to SinglePixmapMsaView at the moment]
      Reason: When a block of sequences are trimmed or extending in some fashion, changes occur at the subseq level.
              Each of these individual changes are responded as they occur. Thus, a single row in the single pixmap is
              updated and colored based upon the information at that point in time - which in the case of clustal
              strictly depends upon the entire column contents. Columns that have not yet been updated.
   2) Low performance. Each individual trim / extension operation causes a painter to be initialized and calculations
      that could be shared.

   Solution: Additional signals from the Msa class that specify the begin and end of block operations. Interested
             components may then connect to these signals and respond upon receiving notification that the block editing
             operation has completed. For instance, only update the master pixmap after the block trim/extend operations
             have ended.

-- Another potential issue with the SinglePixmapMsaView: currently when sliding a region, only that region is repainted
   during changes. While oftentimes accurate, the view may be inaccurate depending on the actual change effected. For
   example, suppose I select a region spanning 80% of the sequences. Moving this may sequences around certainly will
   impact the clustal coloring of the other columns outside this selection; however, they are not updated!

[28 March 2011]
-- Implemented collapseLeft and collapseRight for both the Subseq and Msa classes. During this time, I have found
   several potential performance degrading areas. For example, only the owning class can directly access the raw
   sequence data (and perhaps this is an argument to push all operations to this class), yet the Subseq class has
   specific sequence modifying actions (e.g. collapseLeft). To do this in the Subseq class, we must make a deep copy of
   the source, modify this copy, and then replace the original with the copy. A completely unnecessary operation due to
   COW.

   Then again, perhaps this is a bigger design issue.

[29 March 2011]
-- Did some performance analysis on QByteArray and QString differences in relation to the BioString::normalize method.
   Lessons:
   o It is important to benchmark in release mode, not debug mode!
   o To specify release mode flags for C++, add QMAKE_CXXFLAGS_RELEASE += {...} to the project .pro file

   >> BioString::normalize
   o Regex removal is the slowest of all methods:

     sequence.remove(QRegExp('\\s+'));

     @@ 0.046 msecs per iteration (total: 96, iterations: 2048)

   o Using QChar's is 2x faster:

        const QChar *x = sequence.constData();
        QChar *y = copy.data();
        while (*x != '\0')
        {
            if (*x != Qt::Key_Space &&
                    *x != '\t' &&
                    *x != '\n' &&
                    *x != '\v' &&
                    *x != '\f' &&
                    *x != '\r')
            {
                *y = *x;
                ++y;
            }

            ++x;
        }

     @@ 0.022 msecs per iteration (total: 94, iterations: 4096)

   o Next fastest is multiple QString::remove calls (about 3.6x faster than QChars):

     sequence.remove('\t');
     sequence.remove('\n');
     sequence.remove(' ');
     ...

     @@ 0.00616 msecs per iteration (total: 101, iterations: 16384)

   o Using a QByteArray is the second fastest solution (2.7x faster than QString::remove, 20x faster than regex):

        QByteArray copy = str;

        const char *x = ptr;
        char *y = copy.data();
        for (int i=0; i<l; ++i)
        {
            if (*x != ' ' &&
                *x != '\t' &&
                *x != '\n' &&
                *x != '\v' &&
                *x != '\f' &&
                *x != '\r')
            {
                *y = *x;
                ++y;
            }
            ++x;
        }
        *y = '\0';

     @@ 0.0023 msecs per iteration (total: 76, iterations: 32768)

   o Using pure char array is the fastest, albeit negligibly faster than the QByteArray approach (10%):

        char *copy = new char[l+1];

        const char *x = str;
        char *y = copy;
        for (int i=0; i<l; ++i)
        {
            if (*x != ' ' &&
                *x != '\t' &&
                *x != '\n' &&
                *x != '\v' &&
                *x != '\f' &&
                *x != '\r')
            {
                *y = *x;
                ++y;
            }

            ++x;
        }
        *y = '\0';

        delete copy;
        copy = 0;

   Conclusion: using QByteArray is the fastest and most ideal solution when dealing sequence data. Why? Because it
               provides safety mechanisms to automatic re-allocate on demand, and several convenience functions, plus
               it is highly integrated into Qt. Plus it is very fast and should more than cover the entire span of
               sequence data.

   Incidentally, using QByteArray::at(int) is only very slightly slower than accessing the raw char * directly. Compared
   to the above QByteArray version, it slows things down by .0004 ms. Not worth bothering about.

-- Interesting idea about storing and searching for gaps. Since there are 8 bits per byte, we could make one bit
   indicate whether the character is a gap or not. Since we only use the lower 7 bits, could just toggle the highest bit
   for a gap character. Of course, this alters the actual value of the character though. Unless we made it negative :)

   Probably too much work with too little payoff.

-- For the longest time, I was having issues with the C++ linker. Frequently, it would give me this error:

    MsaRect.o: In function `registerMetatypes()':
    /home/ulrich/dev/qt/AlignShop/tests/TestMsa/../../util/MsaRect.cpp:19: multiple definition of `registerMetatypes()'
    Rect.o:/home/ulrich/dev/qt/AlignShop/tests/TestMsa/../../../../lib/qt-4.7.1/include/QtCore/qbasicatomic.h:78: first defined here

   What gives?! Each registerMetatypes function is only defined and declared within its own self-contained CPP file.
   Turns out that the linker by default makes all non-qualified methods external and thus when two different cpp files
   have the same signature, it appears as though there are multiple definitions. The solution: declare the method as
   static, which localizes it to that single module or source file:

   void registerMetatypes() { ... }
   -->
   static void registerMetatypes() { ... }

[1 Apr 2011]
-- New namespace and class organization:

   -------
   >> Core
      o Rect
      o PosiRect
      o BioString
      o SingletonPtr
      o BioSymbol
      o BioSymbolGroup
      o Seq
      o Subseq
      o Msa

      >> Msa
         o Signalified Msa

      >> Trees
         o TreeNode
         o MpttNode

      >> Seq
         o SimpleSeq
         o AnonSeq
         o DnaSeq
         o RnaSeq
         o AminoSeq

         >> Features
            o GenericFeature
            o DasFeature
            o PfamFeature
            o SegFeature
            o CoilFeature

      >> IO
         >> Parsers
            o AbstractParser
            o SimpleSeqParser
            o FastaParser
            o ClustalParser

         >> Adoc
            o AbstractAdocDataSource
            o SynchronousAdocDataSource
            o ThreadedAdocDataSource
            o AdocTreeNode

      >> Detectors
         o AbstractAlphabetDetector
         o MaxCoverageAlphabetDetector

      >> Inspectors
         o AlphabetInspector
         o ClustalFormatInspector
         o FastaFormatInspector

      >> Validators
         o BioStringValidator

      >> Data
         o CharCountDistribution
         o LiveCharCountDistribution
         o LiveSymbolString
         o LiveMsaCharCountDistribution

         >> Models
            o TableModel
            o SeqModel
            o AminoSeqModel
            o DnaSeqModel
            o RnaSeqModel
            o FeatureModel
            o PfamFeatureModel
            o DasFeatureModel
            o SegFeatureModel
            o CoilsFeatureModel
            o OrgTreeModel

   ------
   >> Sql
      o SqlBuilder
      o AbstractDbDataSource
      o SqliteDataSource

   --------
   >> Tools
      >> External
      >> Internal
      >> Hybrid

   -----------
   >> Graphics
      o TextColorStyle
      o BioSymbolColorScheme
      o CharColorScheme

      >> ColorProviders
         o PositionalMsaColorProvider
         o SymbolColorProvider

      >> Font
         o AbstractCharPixelMetrics
         o CharPixelMetrics
         o CharPixelMetricsF

      >> Renderers
         o AbstractTextRenderer
         o BasicTextRenderer
         o TextImageRenderer
         o TextPixmapRenderer
         o ExactTextRenderer

   ------
   >> Gui
      >> Models
         o NodeTableModel
      >> Widgets
         o AbstractMsaView
         o NativeMsaView
         o GlMsaView
         o AgDoubleSpinBox
         o PercentSpinBox
      >> Delegates
         o LineEditDelegate

-- Data::Models will return objects, not abstracted rows of QVariantLists
   For starters, all Data::Models will return a const <Type > pointer, thus preventing any consumers from directly
   modifiying the object. The Data::Model will contain the various methods for changing an objects values. For example:

   class AminoSeq;
   class AminoSeqModel
   {
   public:
       const AminoSeq *fetch(int id);
       void setName(AminoSeq *aminoSeq, const QString &newName)
       {
           if (!idLookup_.contains(aminoSeq->id_))
               return;

           aminoSeq->setName(newName);
           emit nameChanged(aminoSeq);
       }

   private:
       QList<AminoSeq> aminoSeqs_;
       QHash<int, int> idLookup_;
   };

   This does not limit using AminoSeqs that originate outside the model though, which may be quite handy.

-- AdocTreeNode will only contain names for group/folder items. The structure will look like:

   int id_;
   QString label_;
   int left_;
   int right_;
   int fkId_;
   QString type_;   // Or int
   void *data_;     // Void pointer to relevant object

   Thus, a display model may contain a list of various AdocTreeNodes arbitrarily arranged. If data_ is non-zero, then
   it may be assumed that the corresponding object has been loaded. The display model may cast to the appropriate type
   when needing to access its specific data. For instance, in the data(...) method:

   QVariant data(const QModelIndex &index, int role)
   {
       const AdocTreeNode *node = nodes_.at(index.row);
       if (node->type_ == AminoSeq)
       {
           ASSERT(node->data_);
           AminoSeq *aminoSeq = static_cast<AminoSeq *>(data_);
           if (index.column() == 5)
               return aminoSeq->name();
       }
   }

-- The NodeTableModel can display data from any type in a datagrid format and contains pointers to several underlying
   Data::Models. For example:

   class NodeTableModel : public QAbstractItemModel
   {
   private:
       AminoSeqModel *aminoSeqModel_;
       DnaSeqModel *dnaSeqModel_;
       PubmedModel *pubmedModel_;

       QList<AdocTreeNode *> adocTreeNodes_;
   };

   Its column count will equal the sum of all the columns in all the above seq models. It will know the possible columns
   for each modeled data type and upon examining the node type, will appropriately dispatch the request to the right
   model.

   In this manner, it is possible for a mixed representation of nodes to be present at any given time. It will be the
   user's responsibility to show/hide the relevant columns.

-- Making BioString a QByteArray and remapping all modification algorithms to be 1-based :)

[6 April 2011]
-- Rethinking through the core BioString class. Why impose that at this base level that any visible standard character
   (ascii values 32-126) is invalid - including spaces (e.g. might be considered the ideal gap character). Therefore,
   the only cleansing that is performed on BioString involves removal of all characters outside this range. Unlike the
   previous version, the characters are not uppercased or stripped of spaces. Formatting of this nature should be
   handled upstream to creating instances of this class.

-- Core global files breakdown:

   macros.h
   enums.h
   types.h
   constants.h
   constants.cpp

[7 April 2011]
-- Need a generic header file for declaring and registering the various classes metatypes for signal/slot purposes


[14 April 2011]
-- To split a templated class into a header and cpp file, it is necessary to define those template types that will be
   used - in theh cpp file. Here's an example:

   // File: SortedVector.h
   template <class T>
   class SortedVector : private QVector<T>
   {
   public:
       SortedVector();
   };

   // File: SortedVector.cpp
   template<class T>
   SortedVector<T>::SortedVector() : QVector<T>()
   {
       qDebug() << "Wow!";
   }

   void dummy()
   {
       // Here we instantiate a Int-type sorted vector; necsessary if we want to use integers
       SortedVector<int> intSortedVector;
   }

   Links:
   http://stackoverflow.com/questions/115703/storing-c-template-function-definitions-in-a-cpp-file
   http://www.parashift.com/c++-faq-lite/templates.html [35.12, 35.13, 35.14]
   http://stackoverflow.com/questions/644397/c-class-with-template-cannot-find-its-constructor

   o In general, it is not advised to store the implementation in the cpp file if possible.

-- Qt already has binary search algortihm in place - it just requires a sorted container:

   #include <QtAlgorithms>

   QVector<int> ints;
   ints << 3 << 98 << 100 << 105;
   QVector<int>::const_iterator it = qBinaryFind(ints.begin(), ints.end(), 98);
   int index = (it != ints.end()) ? it - ints.begin() : -1;

   // Or to access the actual integer:
   int value = *it;

   Reference: http://doc.qt.nokia.com/qq/qq15-qalgorithms.html

-- Container review: http://doc.qt.nokia.com/qq/qq19-containers.html

-- Sending email via Gmail: http://glennchen.wordpress.com/2011/02/20/linux-get-your-linux-to-send-email-with-your-google-account-in-1-minute/



[20 April 2011]
-- Model everything as subseqs. Then how to create a new subsequence from the same parent? Copy and paste and then
   tweak the coordinates within the parent sequence?

-- What are the common tasks that people will want to do?

   BLAST -> MSA
   Create a new sequence and annotate it
   Make a MSA from a selection of sequences

-- Challenge = presenting the Sequence/Subsequence relationship effectively. Options:
   1) Show 1-D treeview with parent sequences having subsequences as children
      o How to deal with one master sequence and subseqs scattered throughout?
        - Perhaps only Msa's can have scattered sequences
      o How to deal with users's selecting both full-length sequences and subseqs for alignment purposes?

-- I think the easiest approach would be to model everything as a subsequence and have no sequence concept. The
   AnonSeq would remain though for sharing results and data. This could be a very valuable time-saver.

   Yes, this is immensely simpler to deal with. Handling parent sequence relationships is swine issuous. Major fields:

   internal id [not visible], id, name, source, description, start, stop, AnonSeq (sequence, length)

   [Astrings]
   id *
   sequence

   [Coils]
   id *
   astring_id
   start
   stop

   [AminoSeqs]
   id *
   astring_id
   user_id text
   name
   source
   description
   notes
   start
   stop
   tags

   [AminoMsa]
   id *
   name
   description

   [AminoMsaSeqs]
   msa_id
   amino_seq_id

[21 April 2011]
-- Everything seems to be tidying up nicely regarding the design. Here is a recap:

   o Abstract data store; currently this is a Sqlite database
   o All data store raw I/O is performed via PODs (plain old data structures)
   o DataMappers translate PODs <-> domain objects
   o Repositories maintain a collection of in-memory domain objects and provide facade interface for client code to
     retrieve relevant domain objects.
   o Factories: Create complex objects

   There will be an Adoc instance per data file, which is the root object model. It contains all relevant repositories,
   data mappers, etc. and is responsible for setup, handing these out, saving, and tear-down. In this manner, it is
   possible for multiple adoc's to be open simultaneously within the same instance and eventually exchange data between
   Adocs (although this is not the primary goal at the moment).

   All data access will be synchronous for the time being. If it gets onerous and disperformant (new word :), then an
   asynchronous mode of access will be required; however, I do not see how this will be possible without some serious
   rearchitecturization. Originally, I was thinking of having an additional thread in async mode for doing long
   computational analysis and/or database loading. I think this might run into locking issues; however, with the primary
   synchronous thread. Suppose async thread has locked the database, then user in GUI land tries to access data which
   needs loading = GUI freeze.

   >> Rather, I think the thread should be synchronous if possible for the time being as this will be immensely easier
      to program and just may provide sufficient enough performance. KISS. Computations can be done in separate threads
      and return POD data that in turn can incrementally be pushed to the database as needed (so that GUI does not
      appear unresponsive). Regardless, all derived data should be pushed into the repositories, which then gets synced
      when the user saves the master document.

   >> Can use modal QProgressDialog for any possible large opeartions. For example, suppose the user clicks on treenode
      that contains 20,000 items. Can easily split this into many sub-find operations that correspond to steps used by
      the QProgressDialog. If the user cancels, we simply use the items that have been loaded.

-- Concern: what if user deletes a huge chunk of the tree that has not been first loaded into a repository? For example,
   the user highlights the a high-level node on the tree and hits delete (crazy move, but possible). We do not want to
   persist this until the user saves, but we are unable to erase those objects which have not been loaded.

   >> Answer: Delegate all tree modifications and tracking to a separate tree manager. Before diving in, recall the
              AdocTreeNode structure:

              [AdocTreeNode]
              id
              fkId
              type
              void *ptr

              By default, ptr will be nullptr until it is loaded in a repository. Back to the answer.

              In the scenario above, the tree manager simply detaches the high-level node and saves this subtree root
              pointer in a soft erase container. Then traverse this "obsolete" sub-tree and check if any pointers have
              been allocated. If so, we can assume that they belong to a repository. Call erase for these pointers.
              ** Note, the erased object is not actually freed at this point. It is simply tagged for deletion. **

              If the sub-tree should be restored, then we can simply perform the reverse: traverse the tree unerasing
              all non-NULL pointers, and re-adding the sub-tree node to the real tree.

              In the event, the user saves the project, then we can simply discard all erased sub-trees and go on our
              merry way. This requires in turn that the repositories also save all relevant changes.

[25 April 2011]
-- More development notes:

   o When user clicks on tree node for display in data grid, load all items into repository automatically. A possible
     option is to  iteratively add items to the tableview until the load the is finished so that user can see
     the progress.

   o Similarly, "unfind" all the items for the last clicked tree node. This informs the relevant repository that

   o Since all nodes beneath the selected node will be "found" before their display, there may not be a need to store
     a void pointer for each node. The TableView will receive a list of Vector objects for display.

   o Because operations are now done in bulk, it is more performant to pass Vectors of objects to find/unfind rather
     than isolated instances. Both will be supported, but channeled through the more abstract Vector interface.
     This is also more database optimal because multiple records can be fetched in the same query and they are likely
     to be phsyically closer to.

   o Make the IRepository use IEntity pointers rather than templates. This makes it future-proof for layering on
     signals and slots as needed.

-- Interfaces vs abstract classes in C++

   Interface has only pure virtual methods, protected constructor, virtual destructor, and absolutely no data members.
     Ideally, the constructor does not require any arguments
   An abstract class has one or more pure virtual methods but may also provide default implementations.

[26 April 2011]
-- If base class has a virtual destructor, then all derived classes' destructor's are automatically virtual regardless
   of thow they are declared. If a destructor is needed for explicit purposes, then define one; however, it is otherwise
   unnecessary to specify one in a derived class. See C++ FAQ 20.7:

     http://www.parashift.com/c++-faq-lite/virtual-functions.html#faq-20.7

[3 May 2011]
-- C++ lesson learned regarding calling parent class methods of a templated class. If a derived templated class calls a
   a parent class method that lacks templated arguments, it should be called via the this pointer:

   template<typename T>
   class Base
   {
   public:
       virtual void method()
       {
       }

   private:
   };

   template<typename T>
   class Derived : public Base<T>
   {
   public:
       virtual void anotherMethod()
       {
           // WRONG way to do it - won't compile (error: there are no arguments to 'find' that depend on a template
           //                                     parameter, so a declaration of 'find' must be available)
           method();

           // WRONG - despite the gcc manual saying this will work, when I tried it, I get a linker error
           //         http://gcc.gnu.org/onlinedocs/gcc/Name-lookup.html
           Base<T>::method();

           // RIGHT
           this->method();
       }
   };

   -- It seems this also applies to data members

[4 May 2011]
-- Design issue of making repositories / data mappers / data sources accept only single identifiers or an array of
   identifiers.

   >> Single identifiers
      Pros: o Easier to implement
            o More granular data handling logic
            o Less code

      Cons: o May be inefficient (e.g. at the data source level, must perform hash lookup to get prepared query)
            o Perhaps less cohesive integration with domain model (i.e. arrays may be more natural)

   >> Array or vector of identifiers
      Pros: o More efficient
            o In some cases more natural

      Cons: o Return values for CRUD operations are not well defined (e.g. when adding several entities, what to do
              if one fails in the middle?)

   >> Hybrid: provide both options
      Pros: o Complete flexibility from user's perspective
            o Can be optimized for both cases

      Cons: o More coding
            o Still has the problems associated with the how to deal with return values

-- CRUD return value operations:

   o QVector<T *> find(QVector<int> ids): similarly sized vector of constructed entities; if an entity for a given id
     does not exist, a null pointer will be present.
     -- Logical that an entity with a given id may not exist. Therefore, this should not choke, but rather return a null
        pointer
   o bool add(QVector<T *> entities):
     -- How to handle null pointers?
        >> Ignore them silently without error
        >> Technically, it makes no sense to add a null entity. Throw an assertion
        >> Return false without adding any **
        >> Return false and only add up to that point
     -- Should this be atomic? Meaning all are added fine or none at all? Yes
     -- Perhaps return a vector of bools indicating the success/failure of each individual node...
     -- ** Assume that everything is valid. If an error condition occurs while processing these, revert all prior
        changes and return false. ** ACCEPTED answer
        >> Actually, added parameter to the Generic Repository that allows add to ignore null pointers

   o bool erase(QVector<T *> entities):
     -- How to handle null pointers?
        >> Erasing a null pointer, why not? Does not technically make any sense apart from the fact that we expected a
           non-null object.
        >> But, then again it makes no sense to attempt to erase an invalid object. This is against the nature of the
           API design and likely indicates an upstream issue.
     -- As with add, operation should be atomic and null pointers should not be allowed. Add iteratively. Revert all
        changes upon encountering an error and return false.

[5 May 2011]
-- Was struggling with how to associate relevant objects with the Subseq inside a Msa. And then it dawned on me how
   simple it was! Simply give Subseq an IEntity pointer variable!

   class Subseq
   {
   public:
       IEntity *entity() const;

   private:
       IEntity *entity_ = nullptr;
   };

-- Then to provide views access to this data, create a MsaSubseqEntityModel that utilizes a ColumnAdapter for data
   interchange:

   class MsaSubseqEntityModel : public QAbstractTableModel
   {
   public:
       MsaSubseqEntityModel(ObservableMsa *msa, IColumnAdapter *adapter)
       {
           // Connect msa data changed events to the model's events

           // Connect the adapter's data changed signal
           connect(adapter, SIGNAL(dataChanged(IEntity *, int)), SLOT(onColumnAdapterDataChanged(IEntity *, int)));
       }

   private slots:
       void onColumnAdapterDataChanged(IEntity *entity, int column)
       {
           ASSERT(entity);

           // Check if this entity is in this MSA
           QVector<const Subseq *> members = msa_->members();
           QVector<const Subseq *>::ConstIterator it = members().begin();
           while (it != members.end())
           {
               if ((*it).entity() == entity)
               {
                   QModelIndex index(it - members().constBegin(), column);
                   emit dataChanged(index, index);
                   return;
               }

               ++it;
           }
       }

       int columnCount() const
       {
           return adapter->columnCount();
       }
       int rowCount() const
       {
           return msa->subseqCount();
       }
       QVariant data(QModelIndex &index, int role)
       {
           return adapter->data(msa.at(index.row()).entity(), index.column());
       }
  };

-- Refactored the whole IAdocSource interface because it was getting quite awkward to have to define numerous
   read/save/erase methods for numerous pods. Way too much work at this point in time. Thus,

   1) AdocSource will work with real entity objects
      o Why should AdocSource be shielded from working with domain objects?
      o Also, when inserting records it is no longer necessary to have to update the identifiers externally after the
        object has been persisted (e.g. lastInsertId)
   2) AdocSource will now also factory-style construct the core entities, but not related entities
      o Indeed if it knows how to persist the objects, it already knows enough about the internals of the object, so
        go ahead and make it capable of reconstituting the object as well
      o Building related entities is the function of the mapper.
   3) The necessary CRUD per entity will be abstracted to a common interface (IEntityCrud?)
      o This facilitates keeping all CRUD related code in one place and avoids bloating the AdocSource class with
        numerous CRUD methods only differentiated by a qualified name (e.g. saveAstring vs saveAminoSeq vs etc.)
   4) IAdocSource will expose the Crud interface objects as pure virtual, thus delegating the actual CRUD implementation
      to IEntityCrud.
      o Client classes wishing to do some CRUD will simply utilize the relevant IEntityCrud object

-- The Repository and Mapper classes will remain although much of the code may be boilerplated with Generics and/or
   templating. Actually... templating this out will not work becuase there is no way to get the relevant IEntityCrud
   interface object using just the T method. Specifcally, the return value of the crud object interface method
   would have to be templated, which is not possible for each and every class.

   By Jove it is possible! Simply have to specify it!

   template<typename T>
   class GenericEntityMapper : public AbstractEntityMapper<T>
   {
   public:
       virtual bool erase(const QVector<int> &ids)
       {
           return adocSource_->crud(static_cast<T>(nullptr))->erase(ids);
       }

       virtual QVector<T *> find(const QVector<int> &ids)
       {
           return adocSource_->crud(static_cast<T>(nullptr))->read(ids);
       }
   };

-- This should be pretty swank. Example usage here:

   SqliteAdocSource source;

   GenericEntityMapper<Astring> astringMapper(&source);
   AnonSeqRepository<Astring> astringRepository(&astringMapper);

   AminoSeqMapper aminoSeqMapper(&source, &astringRepository);
   GenericRepository<AminoSeq> aminoSeqRepository(&aminoSeqMapper);

[9 May 2011]
-- Multiple types in one declaration error: check all classes and structs for a terminated semicolon

[10 May 2011]
-- First time I found that dynamic_cast is necessary: when casting base class to derived class that is part of a
   virtual inheritance chain (usually because of diamond inheritance).

[12 May 2011]
-- Template the tree structure to carry an arbitrary data piece.

struct EntityNodeData
{
    int nodeType_;
    QString label_;
    int entityId_;
};

TreeNode<EntityNodeData> *tree;

-- Or, get funky with the templating of an extended TreeNode:

[16 May 2011]
-- Huge success with regard to the gui model for simultaneously viewing multiple heterogenous entities.

[17 May 2011]
-- Undo/Redo is pretty easy with the Command pattern. For example, with regard to AdocTreeModel changes:

   class RemoveTreeNodesCommand : public QUndoCommand
   {
   public:
       RemoveTreeNodesCommand(AdocTreeModel *adocTreeModel, const QModelIndex &index, int start, int end)
       {
           parentNode_ = adocTreeModel->nodeFromIndex(index);
           nodes_ = parentNode_.childrenBetween(start, end);
           setText("Removing nodes from Tree");
       }

       virtual void redo()
       {
           adocTreeModel_->removeRows(start, end - start + 1, adocTreeModel_->indexFromNode(parentNode_));
       }
       virtual void undo()
       {
           adocTreeModel_->restoreRows(nodes_, adocTreeModel_->indexFromNode(parentNode_));
       }

   private:
       AdocTreeModel *adocTreeModel_;
       AdocTreeNode *parentNode_;
       int start_;
       int end_;
       QVector<AdocTreeNode *> nodes_;

       PersistentModelIndex &parentIndex_;  // Alternative to using the parentNode_ pointer
   };

   When a QUndoCommand is pushed onto a QUndoStack, the redo method is automatically called, which carries out
   the specific command. For this to work properly, it requires that all manipulation is done using only the commands.
   An alternative approach is to embed the undo/redo inside the model itself as explained here:

   http://doc.qt.nokia.com/qq/qq25-undo.html

   I would do it slighly differently than presented in the above document because there is only one undo stack and that
   is solely contained within the model. Therefore, I would make it possible to pass in an external undo stack pointer
   and then apply all changes to that stack member.

-- I have implemented an eraser service that synchronizes a repository with removals and insertions into the tree model.
   A possible issue is that of moving nodes around. In essence, this is a remove followed by an insertion. In this case,
   pushing such erase/unerase commands to the repository is unnecessary. Not sure how to get around this. Perhaps with
   another method that suppresses the various signals. Or perhaps a way to temporarily disable the messaging...

   The rowsAboutToBeRemoved and rowsRemoved signals cannot be changed; however, a new signal may be implemented that
   is only emitted when a non-move operation is in place:

   AdocTreeModel: removeRows

[18 May 2011]
-- Got direct access to the Sqlite API. Here's how:
   o Be sure to use the system-sqlite and plugin compilation of the Sqlite driver
   o #include <sqlite3.h>
   o Link against the sqlite3 library that the plugin is linked to. To determine this, use the ldd tool:

     ldd /usr/lib64/qt4/plugins/sqldrivers/libqsqlite.so

     Output ==>
       linux-vdso.so.1 =>  (0x00007fff9aef4000)
**     libsqlite3.so.0 => /usr/lib/libsqlite3.so.0 (0x00007fe96c46c000)     **
       libQtSql.so.4 => /usr/lib64/qt4/libQtSql.so.4 (0x00007fe96c22d000)
       libQtCore.so.4 => /usr/lib64/qt4/libQtCore.so.4 (0x00007fe96bdaa000)
       libstdc++.so.6 => /usr/lib/gcc/x86_64-pc-linux-gnu/4.4.3/libstdc++.so.6 (0x00007fe96baa4000)
       libgcc_s.so.1 => /lib/libgcc_s.so.1 (0x00007fe96b88d000)
       libc.so.6 => /lib/libc.so.6 (0x00007fe96b534000)
       libpthread.so.0 => /lib/libpthread.so.0 (0x00007fe96b318000)
       libgthread-2.0.so.0 => /usr/lib/libgthread-2.0.so.0 (0x00007fe96b112000)
       librt.so.1 => /lib/librt.so.1 (0x00007fe96af09000)
       libglib-2.0.so.0 => /usr/lib/libglib-2.0.so.0 (0x00007fe96ac12000)
       libz.so.1 => /lib/libz.so.1 (0x00007fe96a9fc000)
       libdl.so.2 => /lib/libdl.so.2 (0x00007fe96a7f8000)
       libm.so.6 => /lib/libm.so.6 (0x00007fe96a577000)
       /lib64/ld-linux-x86-64.so.2 (0x00007fe96c930000)

     So simply include -lsqlite in the .pro file

     Helpful link with this information: http://comments.gmane.org/gmane.comp.lib.qt.general/39791

-- To utilize the Sqlite online backup API:

   http://www.qtcentre.org/threads/36131-Attempting-to-use-Sqlite-backup-api-from-driver-handle-fails
   http://www.sqlite.org/backup.html

-- SQLite performance tips:

   http://stackoverflow.com/questions/1711631/how-do-i-improve-the-performance-of-sqlite

[19 May 2011]
-- Definitions (per BioPerl):

   Annotation: description related to sequence object as a whole
   Feature: description related to a specific region of a sequence

-- The notion of a specific location needs to be developed further than simply integral coordinates that denote
   a specific character. For instance, it will become necessary to refer to sites between dna bases, or in the case
   of GenBank records, fuzzy coordinates, etc.

-- Features need to be developed further as well - especially in regard to modifications of the actual sequence itself.
   Thus, there are two primary categories of features:

   1) Static features that strictly depend on the sequence as a whole
      -- If the sequence is modified in any way, these should be detached. Technically speaking, a new AnonSeq should be
         created with this new sequence

   2) Dynamic/live features update the locations of features in light of sequence modifications
      -- For instance, if the user has associated a note with a particular base or residue, then it make sense to keep
         this feature if a distinct part of the sequence is removed. Simply updated its coordinates.

-- Provide a specific dialog for modifying the sequence. This can show the relevant features above/below the actual
   sequence characters. If characters are deleted, simply draw a strikethrough line to indicate those will be deleted.
   If inserted, draw the characters with a different color or in a box to indicate they are novel. Expand feature boxes
   as characters are added.

   When user confirms, simply apply all the changes to the sequence. At this point, if the sequence has been changed, a
   new AnonSeq may be created and assigned to the Seq record.

-- Need to provide a relative coordinate for each Seq record to accommodate partial sequences, yet reflect different
   coordinates. For instance, if the user imports several domain sequences, it would be desirable to specify the actual
   character position for the first character of the domain. Currently, it would just display a 1 for the first
   character. The relative stop could be computed.

[20 May 2011]
-- Finally figured out how to forward declare a specific version of a templated class and specifically, AdocTreeNode!

   class AdocNodeData;
   template<typename T> class TreeNode;         // forward declaring the TreeNode template class
   typedef TreeNode<AdocNodeData> AdocTreeNode; // Now, forward declare the specific instantiation of TreeNode

   It is important that the translation units include both AdocNodeData and TreeNode

   Reference: http://cplusplus.com/forum/articles/10627/

[24 May 2011]
-- Should we have an unknown sequence category?

   Database table: unrecognized_sequences (
      id
      name text
      sequence text
   );

-- Alphabets:

   ACGT                         DnaBasicAlphabet
   ABCDGSTW                     DnaExtendedAlphabet
   ABCDGHKMNRSTVWY              DnaAmbiguousAlphabet - extended dna alphabet plus ambiguous symbols

   ACGU                         RnaBasicAlphabet
   ABCDGHKMNRSUVWY              RnaAmbiguousAlphabet - extended rna alphabet plus ambiguous symbols

   ACDEFGHIKLMNPQRSTVWY         AminoBasicAlphabet
   ACDEFGHIKLMNOPQRSTUVWY       AminoExtendedAlphabet
   ABCDEFGHIJKLMNOPQRSTUVWXYZ   AminoAmbiguousAlphabet - extended amino alphabet plus ambiguous symbols

[26 May 2011]
-- At this point, the Parser classes return a SequenceParseResultPod which consists of a Vector of SimpleSeqPods. If the
   input file structure is valid, the isParseSuccessful will be true, false otherwise. Given a valid parse status, the
   collective grammar may be determined by ConsensusAlphabetDetector. If the grammar is still not determined, then ask
   the user. Based on this grammar, we can then get the ambiguous alphabet from the static
   Alphabet::ambiguousAlphabetForGrammar method. The alphabet's characters may then be supplied to a BioStringValidator
   and each sequence checked for validity. If one or more sequences are invalid, present dialog to user to determine
   next course of action. Otherwise, if all is valid, create Entities for the sequences, add to repositories, and insert
   into the tree.

   // Given:
   SimpleSeqPod pod;
   Grammar grammar;

   // Import process
   if (pod.isValid_)
   {
       if (grammar == eAminoGrammar)
       {
           Astring *astring = astringRepo->findBySeqOrCreate(pod.sequence_);
           AminoSeq *aseq = AminoSeq::create(pod.header_, "", astring);
           aminoSeqRepo->add(aseq);
           AdocTreeNode *node = new AdocTreeNode(AdocNodeData(aseq->type(), "", aseq->id()));
           tree->appendRow(node, QModelIndex());
       }
   }

   ** Outstanding issue: the above are all created entities and thus have negative identifiers. These negative ids are
      also stored in the AdocTreeNode's of the tree. When the user saves in the repo, these ids are changed to their
      new positive ids. How to update the tree after this course of action?

      Proposed solution: Supplement AdocNodeData with an IEntity pointer. When the id field is requested automatically
      use the IEntity pointer if it is not null otherwise use the integer entityId_ field.

-- This entire process should probably be encapsulated in an ImportService class(es).

-- All Entity classes should have a static createEntity factory method that takes the same arguments as the constructor
   except for the id field. The id field will be automatically generated using the ::newEntityId<T>() method and return
   an instance just like the constructor. For example,

   Astring *astring = Astring::createEntity("ABC");

   Constructs astring with an automatically assigned application id.

   o This makes the code much more readable and provides an orthogonal method for distinguishing between the generation
     of new Entities and the reconstitution of stored Entities. Furthermore, when working with repositories using the
     add method, it provides a clear picture of what is happening:

     aminoSeqRepo->add(AminoSeq::createEntity(pod.header_, "", astring));

     In this case, we are adding a novel AminoSeq Entity to the aminoSeqRepo.

[31 May 2011]
-- Epiphanation! QObject's may not be assigned because it is not clear how to handle signals/slots. On the other hand,
   I believe the Troll's solution to this problem is to simply pass around pointers to QObjects. To avoid nasty memory
   leaks, they implemented the QObject object hierarchy. A QObject can have several other QObject's and when one is
   deleted all its children are deleted to.

   All the same, care must be taken that whenever a QObject is deleted, other objects that compose this instance do not
   attempt to access this invalid pointer any longer.

-- If getting weird linker errors such as: "undefined reference to vtable for...", make sure:

   1) All relevant header files are included in the .pro file (namely all headers that have a virtual method)
   2) And that all pure virtual methods are indeed pure virtual. That is they are suffixed with = 0

-- Q_DECLARE_METATYPE specifics: have a single consolidated location for such purposes if at all possible. In other
   words, do not place this at the bottom of each header class, unless it will be globally used for messaging purposes.

[1 June 2011]
-- C++ rule: never call virtual functions from constructor or destructor :)

   http://www.artima.com/cppsource/nevercall.html

[6 June 2011]
-- Potential issue with dangling entities:

   o User opens file
   o Imports sequences
   o Undo's the import (essentially a takeRows operation from AdocTreeModel)
   o Save's file

   This leaves all the recently imported sequences dangling. The reference count is increased when added to the
   repository during the import. We could simply unfind them at this point; however, the imported entity pointers are
   associated with the AdocNodeData and thus its final reference count after the import should be 1 per node.
   Subsequently, they may be found again when an item in the treeview is selected. Thus increasing their reference count
   to 2 per node. We need a mechanism of when the node is actually destroyed of unfind'ing it....

   Or simply do not increase the reference count when associating them with a TreeNode. This may be problematic though
   because it does not free the repository to safely de-allocate those entities that have a zero reference count (in
   reality it is not zero, but we are faking it). If the IEntity class did not ever access the pointer this would be
   sufficient; however, it does require it for the entityId() method.

   Problem with faking it:
   >> User adds sequences and thus each new node has entity pointer
   >> Repository currently has zero ref count for each new node
   >> Repository decides to free-up unused nodes, this includes those just imported
   >> User selects tree item, it has a non-null, dangling pointer (deleted in prior step) and seg faults when the
      entity id is attempted to be accessed via entity_->id().

   Options:
   >> Have a helper friend class for de-allocating TreeNodes
   >> Embed the unfind logic within the AdocTreeNode destructor... not sure this is possible with the current
      implementation
   >> Alternative fake:
      - After save, traverse tree and update the entityId to entity_->id() and set entity_ = nullptr. Thus, we can
        completely ignore reference counting those within the tree. Still do not think this works.
      - Eh... does not work

   Solution chosen: created custom signal for AdocTreeModel that indicates a set of nodes is about to be destroyed. The
      AdocTreeNodeEraserService responds to this signal and unfinds all those entity nodes that have an associated
      entity pointer. Since tree modification commands are friends of the AdocTreeModel class, when they are destructed
      they can simply emit the AdocTreeModel->nodesAboutToBeDestroyed signal in their destructors.

-- To create custom context menus: http://www.ffuts.org/blog/right-click-context-menus-with-qt/

-- Getting weird timer unregister bugs. Error message: "Application asked to unregister timer 0x26000001 which is not
   registered in this thread. Fix application." Turns out to be a bug in the Qt code that should be fixed in upcoming
   versions.

[7 June 2011]
-- To check for complex key sequences in the KeyPressEvent handler, simply use the matches method:

   void Widget::keyPressEvent(QKeyEvent *keyEvent)
   {
       if (keyEvent->matches(QKeySequence::Cut))
           ...
   }

[8 June 2011]
-- For the selectionModel() to be non-null in a Tree/Table/List View, it must first have a valid model class assigned
   via the setModel() method.

-- In a {Tree,Table,List}View, when a node is deleted via the removeRow(s) method, it appears that the current index
   is changed before the rowsAboutToBeRemoved signal is emitted.

-- Stack based variables are de-allocated at the end of the owning classes destructor.

-- C++ notes on how to pass a pointer to an arbitrary class instance method:
   http://www.newty.de/fpt/callback.html#member

   o Must use a static method wrapper that casts a void object to the appropriate type

   Using example of extracting nodes of interest from a tree:

// Normal signature with static method
QHash<AdocNodeType, AdocTreeNodeVector> extractFlat(const AdocTreeNodeVector &nodeVector, bool (*acceptNode)(AdocTreeNode *node));

// C++ signature for using arbitrary object
QHash<AdocNodeType, AdocTreeNodeVector> extractFlat(const AdocTreeNodeVector &nodeVector,
                                                    void *object,
                                                    bool (*acceptNode)(void *object, AdocTreeNode *node))
{
    while (1)
    {
        // Iterating over tree
        AdocTreeNode *node = nextNode();
        if ((*acceptNode)(object, node))
        {
            // Keep the node
        }
        else
        {
            // Ignore the node
        }
    }
}

// Example using a specific class instance
class Model
{
public:
    bool acceptNode(AdocTreeNode *adocTreeNode) const;
    static bool acceptNode(void *object, AdocTreeNode *adocTreeNode)
    {
        ASSERT(dynamic_cast<Model *>(object) != 0);
        Model *self = static_cast<Model *>(object);
        return self->acceptNode(adocTreeNode);
    }
};

Model model;
extractFlat(..., (void *)&model, Model::acceptNode)

-- A functor is a class that looks and behaves like a function by virtue of defining its operator() method.

-- For optimal database execution it is vital to have indices defined on all foreign key columns. It was taking a good
   bit of time to removeCruft() and this turned out to be the result of not having an index defined on
   amino_seqs.astring_id.

-- To do animations, somehow save the index that needs to be updated and then connect its signal to the update slot
   on the item view.

[8 June 2011]
-- Need to create an intermediate object that can reference a substring of a parent sequence and can be changed, but
   does not permit gaps. This would be useful for the AbstractSeqRecord class

-- For getting text replaced with automatic ellipses, look for the QFontMetrics::elidedText() method

-- Gestures only appear to be supported by default for certain OSes... namely Windows 7 and smartphones, etc.

   http://labs.qt.nokia.com/2009/04/02/mouse-gestures-in-qt-apps-to-be-or-not-to-be/

[10 June 2011]
-- To compile AlignShop for windows:

   o Add includepath of src/3rdparty/sqlite to .pro file
   o #include <sqlite3.h> as usual
   o Add sqlite3.c to list of sources

   Reference how to get Sqlite3 working with Qt:
   http://www.mimec.org/node/296

[13 Jun 2011]
-- Should I have two versions of the Subseq class?

   o UngappedSubseq
   o GappedSubseq

   -- Rationale, simple is better, so why not just have one Subseq and use it in context?
      Answer: To incorporate the full functionality in a Subseq is not memory efficient as it makes a full private copy
      of the entire subsequence. This is unnecessary for all records except those in a MSA. Therefore, having an
      intermediate class to handle this is a useful addition.

-- Memory layout options:
   1) Entity has a Subseq
   2) Subseq has an Entity
   3) Mirrored vectors of entities and subseqs

   Not #3 because it is simple a pain to maintain and keep up despite its benefits. #1 and #2 should be used as is
   fitting without any strict rule.

   For instance, #1 makes sense for the AbstractSeqRecord derivates where the subseq (or UngappedSubseq) is not the
   primary object; however, #2 makes more sense in the context of an MSA where the Subseq is the primary object.

[15 June 2011]
-- Thinking through the user interaction and document flow of Msas alongside data persistence and retrieval.

   o A Msa consists of Seq entities along with a gapped representation of that sequence. This design roughly doubles the
     memory usage of the Msa. Specifically the ungapped sequence is stored in the Seq entity and a gapped representation
     is stored in the Subseq used by the Msa.

   Solution: Do not use an UngappedSubseq in the Seq entity. Rather store the start and stop positions relative to the
             parent abstractAnonSeq and provide a method for returning the relevant subsequence.

   o The Msa should be able to be saved separately from the main document. Perhaps this is more evident from a potential
     use case:
     - User has two separate alignment windows open editing distinct alignments
     - User saves alignment A
     - Alignment A alone should be saved and Alignment B remain unchanged
       > As part of the save, removed Subseqs and related Seq entities should be removed from the database
       > The other parts of the document should not be saved

     Possible solutions:
     o Save the entire Adoc along with all of its repositories
       Issues: In the above scenario, when alignment A is saved, then automatically alignemnt B and all its changes
               would be saved. Additionally, any changes to the main document entities would be saved as well. This
               would be confusing because the user hit save from the Msa window and yet the save is propagating to the
               entire document including other windows.
     o Give each Msa Window its own repository setup that purely interfaces with the relevant Seq entities
       Issues: While this would work and require few changes to the repository API, it is not a very elegant or clean
               situation. Depending on the alignment grammar, different complex repository chains would have to
               be created (e.g. AminoSeqRepository for AminoGrammar, DnaSeqRepository for DnaGrammar, etc.).

               Would require syncing global Msa properties (e.g. name, description, notes) among repositories.

       Pros: Saving the Msa would simply mean saving the isolated repo chain. Very easy indeed!

     o Why not simply call save on the appropriate repository type for the Msa?
       Issues: This would work sufficiently except that it does not account for orphaned Seq entities. When a Seq entity
               is removed from the Msa, it should be removed from persistent storage when the Msa entity is saved. This
               will only occur if the user saves from the main document interface. Perhaps a scenario would be clearer:

               - User removes Seq entities from the alignment
               - User saves the alignment
                 > Truncates amino_seq_members
                 > Writes the final alignment to amino_seq_members
                 > Msa Mapper calls erase on the Seq Entity repository
               - User closes the alignment window
               - User closes the program without hitting save

               Result: The Seq entity that was removed from the alignment still exists in the persistent storage. When
                       the Seq was removed and save called on the Msa repository for the Msa, indeed it was tagged as
                       erased from the Seq repository; however, without calling save the Seq repository will not
                       actually remove the entity from the persistent storage.

   >> Proposed solution: provide an immediateErase method to the repository interface that immediately performs a
      persistent erase much like save on the repository performs a persistent save. Additionally, save from main window
      saves everything. Save from derivative windows (e.g. Msa editor windows) only save its relevant slice of data.

-- Document flow. The save and modified state of the sequence organizer and other windows should be kept separate. A few
   use cases to demonstrate expected behavior:

   >> Case 1
   o User opens AlignShop project
   o Changes a property
   o Sequence organizer indicates a modified status
   o Save
   o Sequence organizer indicates a non-modified status

   >> Case 1
   o User opens AlignShop project
   o User opens Msa
   o User modifies Msa
   o The Msa window indicates a modified status
   o The sequence organizer window should indicate non-modified status
   o User attempts to close main window (sequence organizer)
   o The main window prompts user if they want to save the modified Msa
     > Yes, then save and close
     > No, close without saving
     > Cancel

   >> Case 3
   o User opens AlignShop project
   o Changes a property
   o Sequence organizer should show modified status
   o User opens Msa
   o User modifies Msa
   o The Msa window indicates a modified status
   o User saves from the sequence organizer
   o The sequence organizer components are saved, but the modified alignment is not

   Possible issue: user modifies the metadata for an MsaEntity in the sequence organizer and then saves from the main
                   window. Since the MsaEntity is dirty, it will be attempted to be saved from the sequence organizer.
                   This could potentially crash the program because the msa window will not necessarily know about the
                   modified Msa entity state.

-- To enable undo/redo beyond save states, would have to keep the objects in memory. This would be more difficult for
   those entities that were never loaded. For instance, suppose a whole tree section was removed, which in turn calls
   eraseByIds(). If this is followed by a save, the datasource will permanently remove these entities referenced by ids
   and there will be no object in memory to restore it.

   Could provide limited support for such actions, say for example with Msa editing because all of these have to be
   loaded into memory.

-- Example of undo/redo beyond save of Msa:

   MsaWindow maintains its own undoStack and contains one MsaEntity instance
   MsaEntity keeps pointers of removed subseqs
   MsaCrud::save simply truncates members and rewrites current members into table
   The undostack is setClean
   When MsaWindow closes, hardErase the removed subseqs array

   But... suppose the user further modifies the alignment and then elects to not save the most recent changes? Then its
   not clear if the subseqs in the removed array should be hard erased or were part of the latest edit that should be
   ignored...
   >> Perhaps undo to the clean state first and then clear the removed array. But, what happens if it is not possible
      to return to the clean state?

-- Definitely should clear the undo stack when the msa window is closed.

[16 June 2011]
-- Two fleshed out options for the Msa / Main window workflow:

   Solution 1) MainWindow save cascades to all child windows (e.g. MsaWindow)
               - First calls save on all the child windows and then save on its Adoc instance
               Add a hard erase method in the repository interface
               When MsaWindow::save is called, save all Seq entities in the alignment except for those that have been
                 removed. These are not hard erased at this point either.
               When the MsaWindow is closed, calls hard erase for all the removed Seq entities via the repository

   Solution 2) The Msa entity is solely responsible for the subordinate Seq entities. These Seq entities are not
               maintained in a repository - only the Msa entity is maintained in the repository.
               For this to happen, the Msa entity mapper must contain a reference to the Seq entity mapper - not the
                 Seq entity repository. By then requesting the Seq entities directly from the entity mapper they are not
                 stored locally in a repository and can be directly managed by the Msa parent entity.
               On import of an alignment, the Seq entity objects are created and attached to their Subseq counterparts
                 which are then added to the Msa. The Msa is then added to its repo.
               MsaRepo::save method saves only the alignment metadata and its current set of aligned sequences. The Seq
                 entities corresponding to removed Subseqs are not erased from the persistent storage. This must be done
                 by a separate method.

               Note: Only the Seq entities are not kept in the repository. The AnonSeqs which are loaded into the
               repository via the relevant Seq EntityMapper will be stored in the repository.

   o Solution 2 is the most flexible in terms of how to manage what happens when the user saves from one place or
     another. Elected to use solution #2 for now. May change mind later.

-- Interesting feature about SQLite performance and the AUTOINCREMENT option. The default rowid property of a sqlite
   table is to simply take the largest id value + 1. With autoincrement the next id value is guaranteed to be one that
   has never existed before for that table. While this more accurately models sequence specific behavior, it "requires
   additional work to be done as each row is inserted and thus causes INSERTs to run a little slower." Thus, since it is
   not required for our purposes, we can simply remove it at will and get a small speed boost.

[18 Jun 2011]
-- Multiple inheritance in C++ is a tricky beast to master. My primary usage pattern involves building interfaces;
   however, even this may be complicated.

   Perhaps the best approach is to simply make several IInterface classes that never inherit from each other. While
   technically, one interface may extend the other interface (e.g. IBasicEntity extends IEntity), using inheritance
   at the interface class level would quickly create diamonds and other undesirable effects. Secondly, construct
   ABC that inherit from these interface classes. Essentially, make combined interfaces one level lower. This means that
   it is now necessary to program to the ABC interface level when two or more IInterface classes functionality is
   desired.

-- When a diamond does present itself, make both the in-between classes use virtual inheritance. A downside is that it
   is no longer possible to use static_cast to convert a polymorphic top-most pointer to the bottom-most type:

       /--> B \
   A --        --> D
       \--> C /

   D *d = new D();
   A *a = d;

   static_cast<D *>(a)->method(...);    // ERROR! Will cause compiler error!

   The above cast will create a compiler error because it does not know which path to take casting a to D (does it take
   A -> B -> D or A -> C -> D?).

   The solution: make both B and C use virtual inheritance (tells the compiler to only keep one copy of A in the virtual
   table), define a virtual destructor for A, and then use the C++ dynamic_cast (which unfortunately, requires the
   overhead of RTTI).

   dynamic_cast<D *>(a)->method(...);   // Right

[21 June 2011]
-- Thinking how to most effectively communicate Msa changes using signals. Some operations are quite complex and vary
   significantly in the change they might effect. For example, collapseLeft could result in a huge block of changes or
   none at all. What information should be signaled? Per sequence changes? Per block changes?

   Fact: looping through a huge block of sequences and simply incrementing/decrementing can be very quick. And this is
   the primary downstream calculation. It is probably efficient enough (and easier to implement) to simply emit a signal
   defining the region of the modification and the left/right most modified columns. Then connected components may
   simply update their data structures via iterating through this array.

   Concern: emit both About (e.g. AboutToCollapseLeft) and Finished (e.g. collapsedLeft) signals? If a connected
   component simply receives the Finished type signals, it cannot accurately update its data structure. Specifically,
   in the collapse method, it would first have to subtract the existing characters in response to the About signal and
   then add in the characters after the Finished signal. Alternatively, it could always recalculate the counts for the
   entire column; however, this very frequently will be less efficient.

   Conclusion: emit both About and Finished signals and provide the flexibility for connected components to decide how
   best to update their data.

-- Learned a bit more about private/protected inheritance. When working with the Msa::sort method, I wanted to provide
   a basic sort algorithm that directly compared two Subseqs similar to how QByteArray would have done the comparison.
   Because Subseq is a private descendant of BioString this was not directly possible. The compiler would always report
   that BioString is an inaccessible base of Subseq. Confound it - I made the operator< publicly available in the Subseq
   class. That obviously was not enough. Other operators with arguments that were not members of the QByteArray/
   BioString/etc. family were inherited and available. This was my clue. Even though the operator< was publicly
   available in Subseq, it could not be called externally because its argument was being implicitly cast to the parent
   class (UngappedSubseq and in turn BioString) type which is inherited in a protected fashion and thus is not
   accessible.

   Solution: simply define an operator<(const Subseq &) and call the approprate parent class method. This works because
             the operator method is publicy accessible and Subseq is publicly accessible. Moreover, once inside the
             Subseq class it has increased access and can call its parent class operator< method.

[24 June 2011]
-- Funky C++ error: "expected unqualified-id before 'template'"

   Check base classes if they are terminated correctly (syntactically, that is with a semicolon)

-- Demo code to load alignment from database:

    if (node->data_.nodeType_ == eAminoMsaNode)
    {
        AminoMsa *aminoMsa = static_cast<AminoMsa *>(multiSeqTableModel_->entityFromIndex(clickedIndex));
        int x = adoc_.aminoMsaRepository()->beginLoadAlignment(aminoMsa);
        int y = 0;
        while (y < x)
            y = adoc_.aminoMsaRepository()->loadAlignmentStep(4);
        adoc_.aminoMsaRepository()->endLoadAlignment();
        return;
    }

[29 Jun 2011]
-- Think that we need to make an extend, trim, and level tool that the user can select and apply to the msa much like a
   user selects a tool in inkscape or photoshop and applies it to an image. Since there is a directionality to each of
   these, it may be difficult for the user to remember particular keystrokes; however, the mouse direction would be very
   intuitive. Highlighting the changes would be a nice touch: fade out characters to be removed, and show bold versions
   of characters to be added. To further indicate the direction, the selected region would have an open region on the
   side where the user started. For example:

   > Trim left      OR          Trim right <
   ----------+                  +-----------
    Faded    |                  |  Faded
     chars   |                  |   chars
             |                  |
             |                  |
             |                  |
   ----------+                  +-----------

   The opposite above would be for extensions. Perhaps leveling could just show a single vertical.

   To demonstrate which characters would be trimmed is simply a matter of fading them out using opacity. To demonstrate
   characters that would be added, it would be required to implement a specialized PositionalMsaColorProvider that
   could determine which characters were novel relative to the original alignment and then return an appropriate
   TextColorStyle. This would require extending TextColorStyle with a bold attribute. Perhaps we could have the subseq
   of a msa tell us what its next character would be if any and use this information to send out the right text color
   style. But.. this is only part one. That would provide the right style, but we need to have the renderMsaRegion
   or equivalent method also do a sneak peak to find the right character.

[1 July 2011]
-- Dilemma between popping "useless" commands off the stack vs. enabling/disabling the actions that allow such actions
   in the first place. Specifically, there are commands for extend/trim/level which are pushed onto the stack based on
   the current msa selection. In its current implementation any of these commands may be executed with any selection and
   it is possible that some will do nothing in some cases (selection is to the left of a sequence that cannot be
   extended left anymore).

   The current approach is to simply execute the command and inspect the returned SubseqChangePodVector. If it is empty
   nothing was changed, otherwise, the operation did something. But the mechanism for performing these commands in light
   of an undostack is to "push" them onto the stack which calls their redo method. And it is on the undo stack even if
   it did nothing. For example, if the user hits the extend left command multiple times and it does nothing, there will
   be several trivial commands on the undo stack which in turn do nothing. This is annoying and very likely confusing to
   the user (he hits Ctrl-Z and does not see any change undone).

   There are two approaches I can think of:
   1) Run the command and somehow remove from the UndoStack if it does nothing
      - The QUndo Framework does not provide for pushing commands on the stack and then later removing them apart from
        clearing the entire stack.
      - Approach:
        o Subclass QUndoCommand with CustomCommand and have its redo method do nothing the first time it is called (this
          sufficiently prevents it from running the first time it is pushed onto the stack
          > Define a pure virtual method doCommand that returns true if a change occurred or false otherwise
        o Subclass CustomCommand for the actual specific commands and implement doCommand and undo
        o Subclass QUndoStack and override its push method. Call the doCommand method of the command and if it returns
          true, then push onto the stack using QUndoStack's push method.

    class CustomCommand : public QUndoCommand
    {
    public:
        void redo()
        {
            static bool first = true;
            if (!first)
                doCommand();
            first = false;
        }

        virtual bool doCommand() = 0;
    };

    class TrimLeftCommand : public CustomCommand
    {
    public:
        virtual bool doCommand()
        {
            SubseqChangePodVector pods = msa->trimRowsLeft(1, ClosedIntRange(3, 4));
            return !pods.isEmpty();
        }

        void undo() { ... }
    };

    class CustomUndoStack : public QUndoStack
    {
    public:
        void push(CustomCommand *command)
        {
            if (command->doCommand())
                QUndoStack::push(command);
            else
                command->deleteLater();
        }
    };


   2) Prevent calling the commands if it is not possible to perform it based on the current state
      - This would entail performing some calculations everytime the selection changed to determine what operations are
        permitted
      - Probably more tricky for things like collapse commands

-- All things considered, approach #1 seems hackish and not very clean. Plus, it might be less informative to the user
   to always have all the commands always available to them. For instance, if a selection has been made and they right
   click, it is much more helpful to see only those commands that they may actually do something. So... while this means
   more work, I think it is the better approach.

[5 July 2011]
-- Can model the undo/redo view after Paint.NET

-- TODO for tomorrow:
   o Make collapse return SubseqChangePodVector with eInternalChange
   o Enable undo/redo of collapses
   o Bugfix: when an operation is undone, the list of potential actions that may be executed is not updated

-- Other TODO:
   o Show subseqs table data
   o Implement sorting and undo/redo
   o Removing sequences and undo/redo

[6 July 2011]
-- Use state machine to move between editing modes in MsaWindow

[8 July 2011]
-- To make a window delete itself when it closes, use the setAttribute method:

   msaWindow->setAttribute(Qt::WA_DeleteOnClose);      // Delete the window when it closes :)

-- Customizable header view - toggle fields to show/hide:

   o Right click on header view
   o Popup menu with checkboxes of all possible fields. Those that are currently visible are checked; vice versa
   o Or have option to open tools preferences where they can be configured as a whole

   Two implementations:
   1) Have custom popup menu displayed in response to slot
   2) Construct custom QHeaderView derivative that has the above functionality built in

[12 July 2011]
-- Not sure how to handle the sorting issue. Typically, the selection is lost when a sort is performed; however, this
   can be tricky when displaying the data for a specific sequence entity. I would like to preserve the currently
   selected item, update the data, and then reselect after the sort.

[13 July 2011]
-- Looking into using the oxygen icons set. Finding a good location to download them though is quite onerous. So, for
   future reference, use the following link (part of KDE4 package):

   http://mirrors.isc.org/pub/kde/stable/4.6.5/src/

-- To decompress SVGZ to SVG on the command line:

   for i in *svgz; do J=${i%%.*} && gunzip -S .svgz $i && mv $J $J.svg; done

-- For the zoom icon, I simply wanted a magnifying lens icon. The most recent oxygen set did not include just that,
   they always had a 1:2 or +/- in there as well. Found an isolated magnifying lens for the oxygen set online at:

   http://www.iconarchive.com/show/oxygen-icons-by-oxygen-icons.org.15.html

   Actions-page-zoom-icon.png

   Direct link: http://icons.iconarchive.com/icons/oxygen-icons.org/oxygen/128/Actions-page-zoom-icon.png

-- When undo/redo'ing commands, model the scrolling process after the AbstractItemView's. Provide a scrollTo method
   with a ScrollHint delineating how much to show of the rectangle being scrolled to.

[14 July 2011]
-- To disable stupid virtual inheritance warnings from MSVC, add the following in the needed source/header files:

   #ifdef Q_CC_MSVC
   #pragma warning(push)
   #pragma warning(disable: 4250)
   // Code that is affected
   #pragma warning(pop)
   #endif

   https://choorucode.wordpress.com/2010/07/27/visual-c-pragma-warning/

-- Default constructor and virtual inheritance
   http://stackoverflow.com/questions/3524019/default-constructor-and-virtual-inheritance

[15 July 2011]
-- Modal qprogressdialog ansd process events: http://bugreports.qt.nokia.com/browse/QTBUG-10561

-- Added files in the trip to Atlanta:
   o IMsaTool.h
   o AbstractMsaTool.{h,cpp}
   o HandToolMsa.{h,cpp}

   ** Add the copyright preamble :)

-- Directions to Lowe's:
   Exit 114 go North (right), on our left .5 mile

-- Direction to Paul's place:
   4918 Joy Lane
   Lilburn, GA 30447

   Right: Take exit 75 for US-278 W/GA-124 N/Turner Hill Rd (.3 mile)
   Right: Turn right onto the above (5.7 miles)
   Left: S. Rockbridge Rd (2.6 miles)
   Right: N. Deshon Rd (.2 mi)
   Left: Rockbridge Rd (.1 mi)
   1st Right: Stone Dr SW (1.3 mi)
   Right: G1-10 E/US-78 E/Main St w (.5 mi)
   Left: Lake Lucene Rd SW (1.9 mi)
   Left: 5 Forks Trickum Rd SW (.6 mi)
   Right: Cole Dr SW (1.9 mi)
   continue: Camp Creek Rd (.6 mi)
   Left: Joy Ln SW (.3 mi), dest on left

[18 July 2011]
-- Elected to not highlight/expand the current index in response to rows inserted in the model:

    // Model reaction signals: if new rows are inserted, expand that node by selecting it to inform user of the change
    connect(adocTreeModel_, SIGNAL(rowsInserted(QModelIndex,int,int)), SLOT(onTreeModelRowsInserted(QModelIndex)));

    /**
      * Presumably from an import or undo/redo op; visualize the index
      */
    void MainWindow::onTreeModelRowsInserted(const QModelIndex &parent)
    {
        ASSERT(parent.isValid() == false || parent.model() == adocTreeModel_);
        ASSERT(adocTreeModel_->nodeFromIndex(parent)->data_.nodeType_ == eRootNode || adocTreeModel_->nodeFromIndex(parent)->data_.nodeType_ == eGroupNode);

        // ISSUE? Inform user of last change that was undone?
        ui_->treeView->setCurrentIndex(containerModel_->mapFromSource(parent));
        ui_->treeView->expand(containerModel_->mapFromSource(parent));
    }

   The proper way to do this would be from within the undo/redo commands themselves. Not in response to the general
   rows inserted signal.

-- Swine issue:
   When a selected row is removed, the order of events is as follows:
   1) rowsAboutToBeRemoved (model)
   2) currentRowChanged (selection model)
   3) rowsRemoved (model)

   The problem is that we use the row changed signal to update our state machine and this is achieved by posting a
   custom row change event. The problem is that while this event is posted in the currentRowChanged method call, it is
   processed after the rows have been removed. Thus, when the state machine processes these events the model indices
   are no longer valid and cause the program to crash with an out of range error.

   Decided that the state machine was overkill for this purpose. Simply use a WidgetFocusWatcher and update the entity
   when the focus is lost :)

-- In general, it is not a good approach to intermix reset and layoutchanged signals. For example, I was sorting inside
   a model reset (AbstractMultiEntityTableModel) and this was causing issues with updating persistent model indexes.

[8 Aug 2011]
-- Sometimes it is necessary to disable application-wide shortcuts such as those found in QMenu. For example, when a msa
   editing operation is underway (e.g. sliding rectangular region), switching to another msa tool via shortcut keys
   should be disallowed. To achieve this, respond appropriately to the QEvent::ShortcutOverride event. See
   AbstractMsaView::event().

[11 Aug 2011]
-- Tools that can be incorporated into AlignShop:

   o Seg - very easy - relevant files: blast_seg.c; simply incorporate directly in source code form
   o DAS - paid license for it, but need to check that we can distribute it
   o ClustalW 2.1 - went LGPL!!
     http://www.clustal.org/clustal2/

   o Coils = GPL - would have to keep as separate binary and possibly provide source along with license


   ** For notes on distributing GPL programs alongside proprietary tools:
      http://stackoverflow.com/questions/1394623/can-i-dynamically-call-a-lgpl-gpl-software-in-my-closed-source-application

-- The equivalent of /dev/null in windows is NUL
   http://stackoverflow.com/questions/313111/dev-null-in-windows

-- Database preparation for NN-SEC:

   1) Download latest UniRef50.fasta (ftp://ftp.uniprot.org/pub/databases/uniprot/uniref/uniref50/uniref50.fasta.gz)
   2) Extract
   3) Seg: $file -x > uniref.s
   4) Coils: coils2 -f < $file > uniref.sc      18 minutes for 4.15M sequences
   5) DAS: das8 -s -u $file > uniref.das_pred
      little trickier... because it does not output in fasta
      a) read in das data and filter out TMs
   6) remove the old fasta files
   7) makeblastdb -in uniref.scd -dbtype prot   173 seconds!

   o Make available on website for download and integration

-- Psiblast on my machine for 4 iterations with 4 threads takes ~30 seconds and does not output progress data

-- Details of how to tweak blast+ for outputting the scaled matrix data: nn-sec/notes.txt

-- File structure for external tools and files:

   root/tools/makeblastdb LWM
   root/tools/psiblast    LWM
   root/tools/coils2      LWM
   root/tools/clustalw?
   root/tools/das?
   root/blastdb

[15 Aug 2011]
-- When moving folders on the windows platform, the AbstractItemView implementation automatically removes the moved rows
   just after the move operation. This works as expected on Linux, but not windows. Unsure about MacOS. What should
   happen is that when dropMimeData(...) returns true, removeRows should be called and vice versa. A bug has been filed
   for this: https://bugreports.qt.nokia.com//browse/QTBUG-6679

   but it does not look like it is in view to be fixed yet even though a solution has been proposed.

   For now, to get around this, I have overrided the QTreeView::dropEvent and always set the event drop action to
   Qt::IgnoreAction. While not techincally correct, it sidesteps the windows issue.

[16 Aug 2011]
-- To effectively build the debugging helpers on Gentoo it is necessary to install the Qt libraries with the
   private-headers USE flag for the following:

   qt-core
   qt-gui
   qt-script

-- Psiblast requires at least one num_description and/or one num_alignment; however, these numbers do not impact the
   PSSM data whatsoever.

   -max_target_seqs I believe is a convenience method for setting both of these

   Therefore for optimal performance duing psiblast for secondary structure purposes where the alignment and description
   data is unnecessary, it is advisable to simply set num_descriptions to 1 and num_alignments to 0.

[18 Aug 2011]
-- When building configuration classes for external tools, it may be preferable to have the ability to use program
   defaults without having to hard code them all into specific variables. For instance, the default BLAST matrix is
   BLOSUM62 and this can be configured in the constructor. Alternatively, it is possible to simply leave this empty
   and have the blast executable use its default option. This works well for QString variables, which can be readily
   tested for the NULL case (user has not defined a matrix), yet this is not so easily done with the built-in data types
   such as int (e.g. number of iterations).

   One possible solution is to simply use QVariant's instead of specific data types. Or more abstractly, simply use a
   QHash of QStrings. While this may be more abstract it is less amenable to validation.

   For now, will simply stick with built-in datatypes where the default is defined for every config variable, QString or
   not.

-- Files to be tested:

   FannWrapper - done
   PsiBlastConfig - skipped
   PsiBlastWrapper - done
   PssmParser - done
   PssmUtil - done
   NNStructureTool - done
   PsiBlastStructureTool - done

-- Other outstanding things:
   o Tons testing!
   o GUI interface
   o Visualization

[19 Aug 2011]
-- PssmParser::parseFile [done]
-- Normalized pssm [done]
-- PSSM score order mapping [done]

-- Another issue:
   o Need to provide for when there are no hits to a sequence and therefore cannot predict secondary [done]

-- TODO:
   o Give Astring a Q3Prediction member
   o Supply storage mechanism in database for Q3Predictions

     create table amino_seq_q3 (
         amino_seq_id integer not null primary key,
         q3 text not null,
         confidence text not null
     );

     q3 simply is a string consisting of the Q3 prediction
     confidence will simply be a comma separated list of the confidence for each character:
        ".992,.435,.123,.034,.044,...,.834"

     Thus, converting the data simply consists of splitting on the commas

[22 Aug 2011]
-- Because of the integration of AlignShop with several disparate components/tools and the need to run numerous
   computational results, it is necessary to build in a task manager of sorts that can analyze huge chunks of data
   easily and provide status information to the user. Basically batch processing with a few clicks.

   At the core, each analysis is represented by a single task instance. These will be QObjects because of the need to
   output signals about its status and so forth. Next a task manager class will aggregate a model for the active tasks
   and another model for the pending tasks and possibly another model for the finished tasks. Additionally, it is the
   master controller of executing and running the various tasks. Finally, to display this data to the user, a task
   view/dialog/window class will provide the interactive controls.

   For organizational purposes, tasks may be arranged into a hierarchy similar to how the Undo/Redo framework groups
   various commands. This provides for grouping such things as grouping the prediction of secondary structure for an
   entire alignment.

   When determining the next task to process, the task manager has two parameters to tune its action: max threads and
   max jobs. Whenever the task manager is started, it will iterate through its active tasks and continue to activate
   any remaining tasks. We begin with the active queue first, since the hierarchical nature of tasks mean that the task
   manager may not be able to begin all jobs within a master task. If there is still capacity to process additional
   tasks, the next task will be dequeued from the pending queue and its analysis begun.

   When a task is started, its pointer address will be remembered by the TaskManager and will attach to the Task's
   signals to know when it finishes/begins/errors. The Task will be freed when moved to the finished model and only its
   relevant metadata stored. For example, after a BLAST finishes, it may be desirable to double click on the finished
   BLAST report to navigate to this BLAST report on the document tree and then open it for viewing.

[24 Aug 2011]
-- Now integrating the secondary structure into Astring. The easiest thing is to simply add a Q3Prediction to Astring;
   however, it is located under the PODs directory and not ValueObjects. Decided that if a data structure may function
   as both a POD and ValueObject, it should be stored under the PODs directory. Moreover, it is ok for an Entity to
   use a POD as a ValueObject.

-- Changes to make Q3 Prediction go full circle:

   o Astring: Q3Prediction along with get/set methods [done]
   o SqliteAdocSource: create tables [done]
   o IEntity / AbstractEntity: dirty flags support [done]
   o DbAstringCrud - readQ3/saveQ3; utilize dirty flags [done]
   o LinearColorScheme [done]
   o SecondaryStructureColorProvider [done]

[25 Aug 2011]
-- Add priority to a task?

-- http://www.workwithcolor.com/color-converter-01.htm
   http://stackoverflow.com/questions/3017019/non-linear-color-interpolation

-- Issue: when initializing a FANN struct from a configuration file, there is no error structure to capture the
   errors and thus, unless an error file is supplied, all errors are dumped to stderr. In our case, this is undesirable
   because we don't want these messages arriving to the user; but it requires a file handle if not going to stderr!
   And.. I don't want to create a stupid temporary file for these either.

   Solution: Create a pipe and then open derive a file handle from this pipe.

   int pipefd[2];
   pipe(pipefd);
   FILE *fh = fdopen(pipefd[1], "w");

   fann_set_error_log(nullptr, fh);

   ** Note: the current windows versions of these files are prefixed with an underscore (e.g. _fdopen, _pipe)
      Ref: http://msdn.microsoft.com/en-us/library/ms235351%28v=vs.80%29.aspx

   Interestingly, I suppose this could also be used to bypass the need to have a separate neural network file. For
   example, could store NN as resource file, open pipe and associated file handle, dump data to the pipe which will
   in turn be passed through the file handle pointer to the fann library:

      QFile file(":/path/to/nn-resource.net");
      file.open();

      int pipefd[2];
      pipe(pipefd);
      FILE *read_fh = fdopen(pipefd[0], "r");
      FILE *input_fh = fdopen(pipefd[1], "w");

      while (line = file.readLine())
      {
          fwrite(input_fh, line);
      }
      close(input_fh);
      fann_create_from_file(read_fh?)

   Nah, do not think this will work because fann_create_from_file requires an actual filename, which it turn then
   attempts to open.

[29 Aug 2011]
-- Not testing Task, ITask, or PointerTreeNode

-- Elected to keep the individual completed/errored/pending/done task models as separate Task models and then build
   a super-task-model that combines these into a single tree view. For lack of more creativity, this super task model
   is named: CpdeTaskModel, where each of the letters in Cpde corresponds to one of the task models it integrates:

    c -> completed
    p -> pending
    d -> done
    e -> error

-- CpdeTaskModel is a pretty cool example of how to make one model aggregate other models.

[30 Aug 2011]
-- QColor stores all its color information as unsigned shorts.

[31 Aug 2011]
-- The trick to sequence labels in the QGraphicsView was not to exactly scale the text, but rather utilize the largest
   font size that would still fit in the height returned by char pixel metrics. By using a non-scaled font, we get very
   crisp label renderings. Yehaw!

-- QGraphicsView notes:

   o Only visualizes those items contained within the area defined by the Scene Rectangle
   o The scene rect directly correlates to the ranges supplied to the scrollbars
   o The scrollbars must have a non-zero range to enable panning regardless of their visible status
   o The best way to move the view around the scene rect is using the QGraphicsView::centerOn method. There is a
     translate method; however, this has some strange behavior

     https://bugreports.qt.nokia.com//browse/QTBUG-7328

   o Think of the scene rect as the area available to the view
   o It is sometimes necessary to make the scene rect larger than the actual space avaiable

[1 September 2011]
-- If graphics items are not part of a scene, then it is more than appropriate to call delete on them as needed; however
   if they are part of a scene, the only valid channel for removing these items is via the scene method: removeItem.
   After that, it is then safe to de-allocate them.

-- It is only possible to capture the key events if the relevant widget is focused. Thus, when responding to mouse
   events it is preferable to use the modifiers() event method to check for modifier keys. Still not sure how to capture
   other keys.

-- The boundingRect function for QGraphicsItem subclasses is vitally important not only for optimal painting, but also
   with regard to keeping the index up to date and properly handling deleted items. For instance, if the boundingRect is
   not accurate, the BSP index may still keep a link to an item that has already been deleted. This was happening on the
   MSA label view where I changed the font during a zoom operation, but did not call prepareGeometryChange() on each of
   the items. PrepareGeometryChange informs the index and scene that its bounding rect is about to change and thus it
   can appropriately update its internal state.

   Always call prepareGeometryChange any time a modification would change its boundingRect.

-- When dealing with QGraphicsItemGroup (e.g. MsaColumnItemGroup), it is important to note that this method preserves
   the item's position in the scene before it is added to the group. Thus, for any local coordinate changes, first call
   addToGroup, and then modify its position.

[2 September 2011]
-- It is important when comparing the visual output of a normal QWidget and a QGraphicsView that one is certain that
   identical brushes and pens are being utilized. In essence, the entire QPainter state should be compared to ensure
   that they are identical.

   I originally wrote the label display to use a QGraphicsView, but then decided that a custom QWidget would work
   better; however, when comparing their output, I noticed that the QGraphicsView gave slightly different results - the
   text was slightly lighter. Turns out this was due to QGraphicsView setting the default pen to QPalette::Text color.

-- To build psiblast on windows:

   o Decompress the ag-blast-2.2.25
   o Open Visual C++ 2008 Express Edition
   o Open the file compilers/msvc900_prj/static/build/ncbi_cpp.sln project file ("solution")
   o Select Release DLL
   o Set the configuration options via command line arguments:

     - Not sure how to do this!

   o Right-click -CONFIGURE- | Build
   o Wait for it to completely finish - click ignore on file reload alerts
   o Close and re-open solution
   o Right-click xblast.lib | Build
   o Right-click psiblast.exe | Build

   ** References:
   http://www.ncbi.nlm.nih.gov/books/NBK7167/#ch_config.Configuring_with_Vis
   http://www.blaststation.com/freestuff/en/howtoBuildBlastWin.html

-- For an example on using margins in a QAbstractScrollArea, see the code-editor example:
   http://apidocs.meego.com/1.1/core/html/qt4/widgets-codeeditor.html

[5 September 2011]
-- To determine 32 or 64 bit architecture on linux:

    HARDWARE_PLATFORM = $$system(uname -a)
    contains( HARDWARE_PLATFORM, x86_64 ) {
        # 64-bit Linux
        message(64 bit)
    } else {
        # 32-bit Linux
        message(32 bit)
    }

    Reference: http://lists.trolltech.com/qt-interest/2005-11/thread00305-0.html

-- To determine 32 or 64 bit on windows (untested):

   win32-msvc*:contains(QMAKE_TARGET.arch, x86_64):{
      message( "Building for 64 bit")
   }

   Reference: http://developer.qt.nokia.com/faq/answer/how_can_i_detect_in_the_.pro_file_if_i_am_compiling_for_a_32_bit_or_a_64_bi

[5 Sep 2011]
-- Current outstanding tasks:

   o Dynamic ruler on top of MsaView [done]
   o Show/hide dynamic ruler [done]
   o Show/hide msa side widgets [done]
   o Toggle start/stop/inverted start/inverted stop position type for side widgets
   o Editor widget for label view [done]
   o Delete sequences from the label view using the delete key [done]
   o Label view font
   o Option for moving label view to right hand side of alignment
   o Optimize menu layout [done]
   o UngappedSubseq - relative start (and implicitly relative stop) [done]
   o Configuration pane
     - External tools
       > PsiBlast
         * Executable path
         * Blast database path
         * arguments
     - Msa view
       > Font
       > Font for side widgets
       > Colors for side widgets
     - Msa Window
       > Logo hidden by default [done]
       > Label view by default [done]
       > ...
     - Task manager
       > Processors/threads
     - Logo
       > Show horizontal bars
       > Show numbers beneath columns
   o Logo mouse position and selection [done]
   o Logo axes and horizontal bars [done]
   o Show/hide logo [done]
   o Menu item for collapse/expand label view [done]
   o Minimum size for msa view and prevent complete collapse [done]
   o Task manager tests
   o Task model tests
   o Task manager control pane with start/stop/restart/clear
   o PredictSecondaryTask tests
   o BLAST database manager
   o Architecture specific binaries for all external tools
     - PsiBlast
     - makeblastdb
     - ClustalW
   o Double click amino msa on windows should not start editing name [done]
   o OpenGL MsaView for performance purposes [delayed]
   o Highlight in label view those sequences that are selected in the msa view [done]
   o Column select via dynamic ruler on top
   o Find sequences spanning gap region (ie. old Right click on gap column to navigate to first sequence with non-gap
     character in this column)
   o Help architecture
   o When user deletes alignment from main document interface and msa editor window is open, first request to close it
     first.
   o Command compression for SetSubseqStartCommand

   o Integrate the FANN library as dependent project (using .pri files)
   o Integrate NCBI architecture specific binaries
   o Windows menu from the main window - in other words, dynamic menu with an entry per open msa window
   o Export for alignment
   o Save image of alignment

-- Figured out the approach for displaying the dynamic ruler relative to the zoom. Problem: Given a dynamic zoom range
   determine an aesthetically and practical manner of displaying appropriate labels and ticks corresponding to a graph
   (or msa, in this case).

   Some constraints:
   o Labels should be located roughly every inch
   o The label bounds are 70% to 130% of every inch, once this is exceeded the next higher label increment should be
     used
   o The label increments are 1, 2, 5, 10, 20, 50, 100, etc.
   o Without any scaling, the label increment is every 10 msa columns
   o Pixels per inch is given by logicalDpiX()

   Some example calculations:
   - Given a unit width (msaView->charWidth, which corresponds to the block width) of 8 px and 100% zoom, which label
     increment is used and where is the first label positioned? dpiX = 96

     Determine where the first label would be if we used a label increment of 10: 10 * 8 = 80px
     Is 80px within the accepted normal range (70% - 130% of an inch)? .7 * 96 = 67; 1.3 * 96 = 124
     ==> Yes, therefore its position would be at 80px and the label increment to use is 10

   - What about for unit width of 5px?

     5px * 10 = 50px, which is less than the minimum 67px. Therefore, try the next largest label increment (20)
     5px * 20 = 100px, which is between 67 and 124. Label increment every 20 msa columns.

   - What about for unit width of 28px?

     28px * 10 = 280px, which is greater than 124px. Try the next smaller label increment.
     28px * 5 = 140px, which is still greater than 124px. Try the next smaller label increment.
     28px * 2 = 56px, which is smaller than 67px... what to do? Make 5 columns the smallest limit. Therefore, just 5 :)

   Perhaps define 5 as the smallest increment to place labels

   ** Any increased zoom level, only show tick marks at every column
   ** At any decreased zoom level below 100%, show the unbounded label increment number of tick marks. In other words,
      calculate the number of tick marks similarly as the label increment, except do not cap at 5. The cap should be at
      0.

-- Measured zoom levels in inkscape for when the label changes:

   Units: pixels
   Tick mark every      Zoom range
   500px                  ?   -> 26%
   250px                  27% -> 66%
   100px                  67% -> 132%
   50px                  133% -> 200%
   25px                  201% -> 500%
   10px                  501% -> 1000%
   5px                  1000% -> 1782%
   4px                  1783% -> ?

[7 Sep 2011]
-- To manually trigger an edit within an ItemView, simply call the edit method with its relevant index.
   Motivation: we have double click take two different actions depending on what cell is clicked in the multi seq table view.
               If the cell is a msa node, we want to open a msa window for this msa - and not start editing. All other nodes,
               should beginning editing when double clicked.
   Issue: Originally had the double click as an edit trigger for the table view and slot for when the user double clicks on a
          node. In linux, things worked as expected; however, in windows, both actions occurred when a msa node was double clicked.
          Namely, it opened the msa window and began editing.
   Solution: remove the double click editing trigger, and implement the relevant logic in the double clicked slot.

[8 Sep 2011]
-- It does not appear possible to have GCC/G++ generate an equivalent warning to MSVC's C4099 about mismatched naming
   of classes and structs.

   http://stackoverflow.com/questions/5712514/can-gcc-produce-struct-class-name-mismatches-like-vs

-- Attempted to simply use a GLWidget instead of the normal QWidget for the NativeMsaView; however, on linux (in release
   mode) this gave even worse performance than simply using the QPainter as normal. Same deal for windows.

[9 Sep 2011]
-- To collapse a splitter section, it is necessary to call setSizes :\ with a value of zero. Unfortunately, this
   requires also to specify a size for the other sections.

   To check if a section is collpsed, call QSplitter::sizes() and check for a value of 0, which indicates that it has
   been collapsed.

[12 Sep 2011]
-- Blast database management:

   o 3 sources of blast databases:
     1) Internet
     2) Local files
     3) AlignShop sequence sets

   o Overal process of creating a blast database
     - Download
     - Decompress (optional)
     - Format

   o Blast databases are not specific to a particular AlignShop-file or even necessarily AlignShop (they may be used by
     numerous other applications). Consequently, it does not make sense to privately manage these databases. A
     configuration option should specify one or more paths where BLAST databases are located. It is possible that BLAST
     databases may already exist in this location, created there externally independent of AlignShop, or created via
     AlignShop's interface. All three options should be supported.

   o Should be possible to discover and describe existing blast databases - this will be done via blastdbcmd

   o All blast databases will be discovered upon startup and the relevant BLAST paths watched throughout the duration
     of the program for new database or modifications.

   o The proper execution of BLAST from within AlignShop requires that the blast database be formatted with the parse
     seq ids option. If this is not the case, then it will not be possible to retrieve the full length sequences from
     the BLAST database. To determine if this has been done, it is necessary to check for the following files:

     <database>.pog
     <database>.psd
     <database>.psi

     If these are not present, the database must be reformatted with the -parse_seq_ids option.

   o Blast database properties:
     - file path
     - molecule type: protein or nucleotide
     - title
     - number of bases or residues
     - number of sequences
     - number of bytes
     - ready for usage

   o Blast databases will be managed by the blast database manager interface - not by the task manager. Perhaps this is
     not such a good idea.

   o Relevant Qt classes:
     - QNetworkAccessManager: downloading files
     - QFileSystemWatcher: for monitoring presence/absence of BLAST databases

   o Will need special handling for NN-Sec databases - perhaps the best bet is to allow users to use whichever database
     they want, but provide method for downloading these preformatted databases.

-- Blast results are stored as tsv files and are not by default loaded into the active AlignShop data file. This might
   be confusing.

-- It might be useful to have a "project-specific" blast database path. For example, if there are blast databases
   relevant only to a specific project (e.g. BLAST database for validating HMM models).

-- Interface:
   TreeView:
   >> Special top level item "Create..." (if drag items onto this, will automatically begin the process?)?
   >> top level item for each defined path (including BLASTDB)
   >> Leaf items are databases of all types found by blastdbcmd
   >> In-between items are simply filesystem paths below the top level item paths

-- In many cases, it is desirable to associate files with an AlignShop project but not necessarily store them within the
   sqlite database. For instance, if a user BLASTs 100's or 1000's of sequences this would significantly bloat the core
   database file. It is preferable to store these as external files as *links*. For cases where it would be useful to
   have the BLAST embedded, an option will be provided to *embed* this data.

   Where to store these external files? In a subdirectory that is the same name as its associated data file with a .data
   suffix. For example, "PAS_domains.ap" would have a "PAS_domains.data" subdirectory in which all relevant files would
   be placed.

   A portable version of the file can be created which is a compressed version of the core data file and its data
   directory. When such a portable file is opened, it is first decompressed and then opened by the main program.

-- The data subdirectory will contain a definitive structure. Initially, it will only be used to contain BLAST results
   but this may change as other relevant files are needed.

   / {root}
   /blast
   /blast/{blast task}/

   Each BLAST task will be given a user-defined title (with an automatic suggestion based on the sequence(s) being
   BLASTed). If a task contains only one sequence, it will be placed directly under the blast subdirectory and named
   with the first 12 characters of the sequence title followed by a dash and a random string of 6 alphanumeric characters
   with a .blast extension. If more than 1 sequence is to be BLASTed, the same naming convention as above will be used
   but for the subdirectory. Each individual blast will then be the sequence identifier and the .blast suffix.

-- Possibly move the task manager treeview to the main document view. If a user clicks on an item there, show its
   details in the table view.

[19 September 2011]
-- Context menu events vary from system to system:

   Linux: on right click *press*
   Windows: on right click *release*
   Others: separate key altogether

   http://labs.qt.nokia.com/2006/05/27/mouse-event-propagation/

[20 September 2011]
-- To attempt to merge undo commands, it is necessary to return a positive id for the virtual id method.

-- BLAST databases can be divided into multiple volumes and combined using an alias file which has the .pal extension
   (at least for protein sequences).

[21 September 2011]
-- When dealing with DLL's there are two forms:

   o Implicitly linked: symbols are written into the executable space and program will not even start unless it can find
                        the DLL before startup. To utilize classes, it is vital to use this form. Compile-time.
   o Explicitly linked: These may be loaded at run-time using QLibrary or LoadLibrary. It is necessary to first resolve
                        the relevant symbols before using them. Can also use add library path for this to work.

   http://doc.qt.nokia.com/latest/qlibrary.html
   http://developer.qt.nokia.com/forums/viewthread/6016
   http://developer.qt.nokia.com/forums/viewthread/9628

   Workarounds: batch script

-- When creating an executable with implicitly linked DLL's the .lib files are required.

-- Rendering notes:

   o When painting a stroked rectangle using the drawRect method, it will render outside of the requested rectangle by
     the line size. Thus, given a line width of 1,

     painter.drawRect(QRect(10, 10, 10, 10));

     renders from (10, 10) -> to (20, 20) [actual width and height = 11]

     Given a line width of 2: (10, 10) -> (21, 21) [actual width and height = 12]

     > Note, this is for a QRect, not QRectF.

   o fillRect with QRect works as expected and will only fill the requested rectangle; however, this is not the case
     with QRectF - they will be off by one pixel.

[23 September 2011]
-- QFileSystemWatcher unfortunately is not very efficient nor informative when it comes to monitoring changes. It is
   purely limited to watching a specific directory or file and indicating if it is changed. How? It does not say. Did it
   move, get deleted, rename, modified, etc.? And the directory changes? Again, no information on how. And for every
   file that gets changed, a directoryChanged signal is emitted. Thus, if a file is being rapidly modified (say a blast
   database is being built), we will be flooded with signals and to determine what exactly the change was is not a
   trivial process (get old list of files and parameters and perform a set difference with the new set of files). A big
   swine pain in the rear.

-- So for blast database management, I have decided the following compromise. Upon adding a blast path, it will perform
   an initial scan for blast databases and will not be updated unless the user triggers a refresh. It's all manual, but
   there is no good automatic way to handle this without too much trouble.

   Another essential component is that all tools / code that attempts to utilize a BLAST database, should check for its
   existence and throw an error if it is not found.

   The refresh should cause the BlastDatabaseModel to do a merge from BlastDbMetaPods.

-- Downloads... how to handle downloads. For starters, only support downloading preformatted databases from NCBI.

-- To decompress the tarball, use the QuaZIP? Nah, much easier to just use zlib straight up.

   http://zlib.net/zlib_how.html
   http://zlib.net/zpipe.c
   http://blog.lugru.com/2010/06/compressing-decompressing-web-gzip-stream/

-- For custom unarchiving of tarballs, the specification is rather straightforward:

   http://en.wikipedia.org/wiki/Tar_%28file_format%29
   http://stackoverflow.com/questions/2505042/how-to-parse-a-tar-file-in-c

-- If I choose to use an existing project to unarchive a tarball, checkout libarchive:
   https://code.google.com/p/libarchive/

[26 Sep 2011]
-- To query any BLAST database by its ordinal id, use the -entry argument and specify the oid as 'gnl|BL_ORD_ID|{oid}'
   Ordinal or OIDs are zero-based and do not require the database to be formatted with parse_seqids.

[27 Sep 2011]
-- Because it is possible to retrieve sequences using their OIDs, it is no longer necessary to require blast databases
   formatted with parse_seqids. This is much more advantageous because it is less restrictive on the user and it means
   less processing that has to be done when discovering BLAST databases.

[5 Oct 2011]
-- Classes needing unit tests:

   o Pipe
   o GunzipPipe
   o GzipPipe
   o TarHeaderPod?
   o UntarSink

-- Finally! Got things back compiling on windows again. The crashes related to not finding msvcr9.dll and ntdll.dll etc
   were all related to a fann.dll issue. Specifically, it was being compiled without embedding the manifest and thus
   attempting to find the msvcr9.dll in the windows/system32 directory. But VS2005 and VS2008 utilize the WinSxS
   structure and thus their runtimes are not located in the system32 directory, but the WinSxS directory. Consequently,
   the appropriate dll for fann.dll was never found.

   The fix was to embed the manifest into the fann.dll itself:

      CONFIG += embed_manifest_dll

   I thought that this was done automatically, but apparently it was not. Or rather, my statement, CONFIG = release
   probably clobbered this. Nope. It is necessary to explicitly set the above.

[7 Oct 2011]
-- To find out the exception information thrown by NCBI_THROW, check out the CException class:

   http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCException.html

[11 Oct 2011]
-- NCBI pre-formatted BLAST databases are quite handy; I will create the same for the UniRef databases on AG's ftp site:

   ftp.agilegenomics.com/blast/db

   o Supported BLAST databases:

     - UniRef100
     - UniRef90
     - UniRef50
     - MiST2

     - UniRef50 Filtered - for NN-SEC purposes

   o Tweaks to the UniRef database deflines:
     - Remove the UniRefXX_ prefix to all accessions
     - Convert to makeblastdb acceptable defline:
       sp|{accession}|{entry_name} {description} [{Organism}]

   o MiST2 defline format:

     - lcl|{protein_id} {description} [{Organism}]
     - Taxonomy ID

   o Store as gzipped tarballs for facilitating usage of the existing BLAST database download interface in AlignShop

-- To reuse the blast database download interface, generalize NcbiBlastDatabaseInstaller to
   FtpTarBallBlastDatabaseInstaller, which requires a ftp host and path, and prefix as configuration and is able to
   automatically download tarballs.

-- Mechanism for batch and/or long-running jobs - shoot any type of external task for that manner. The tricky part
   involves how to create nodes in the data tree that correspond to these processes and making it play nicely with the
   undo/redo framework.

   Example: BLASTing a set of proteins
   o BLAST button on the toolbar is enabled when 1+ amino sequences or 1+ nucleotide sequences are selected. Otherwise,
     it is disabled
   o User presses the BLAST button, which opens up the BLAST dialog
   o After configuring the parameters, user submits job to task manager
   o Creates the corresponding nodes in the data tree - 1 per sequence to be BLASTed as "disabled" progress-style nodes
   o As each blast job is completed, it "enables" its corresponding node in the data tree and makes it available for
     display
   o If the user undoes the creation of these nodes, it will warn and give the user a chance to cancel the undo
     - User confirms undo:
       > Kill the BLAST job
       > Remove the corresponding BLAST nodes
       > Tag the finished BLAST files to be deleted on destruction (set a flag in QUndoCommand that will remove it
         during its destruction)
     - User cancels undo - do not pop the undo command off the stack
   o If the user redoes the BLAST job, only restore the nodes. Do not retask the BLAST job for any unfinished sequences

   This would work equally well for MSA or other external jobs.

[13 October 2011]
-- In task manager can kill/pause/ultimate control of any job regardless of its origination. Any changes should be
   propagated to connected components by a third party class that observes the task manager. For instance, in the case
   of BLAST reports or constructing an MSA, these nodes would be synchronized by something like a
   TaskAdocTreeNodeSynchronizer class which can observe and propagate the relevant changes.

   On the other hand, deletion of a node that is linked to a task which is either pending or currently running is not
   allowed. This also applies to deletion of a set of mixed nodes in which one or more is linked to a pending or current
   task.

   The two locations where deletion of a node is possible: 1) user selects nodes and then presses delete 2) undo'ing
   node creation that is associated with a task. In both of these cases, the user should be informed of why their action
   was ignored.

   In the case of the user manually deleting nodes - need a centralized location => model removeRows command - but by
   this time it is too late because the model will not necessarily know the widgets for alerting to the user.

[14 October 2011]
-- Continuing the above thoughts.

   I think the checks will have to be done in a logical manner outside of the model->removeRows() method. At the current
   time and for the foreseeable future, this will be in a single place: an onDeleteSlot(). It should be fairly easy to
   check this.

   Undo however, will permit the entire job to be canceled - yet with confirmation from the user. This is because the
   undo mechanism can easily check whether or not to continue the undo via the acceptUndo() method, yet it cannot
   necessarily inform the user of why without some non-general methods (e.g. reason(), setReason() within conditional
   UndoCommand).

   For example, in the situation where a user submits 1000 jobs to be BLASTed, a master folder is created and 1000 BLAST
   report nodes are created within this folder. The user then presses undo, which triggers the acceptUndo() virtual
   method. The BlastCommand defines acceptUndo() and finds that one or more BLAST tasks are pending/current and alerts
   the user that continuing the undo will cause these jobs to be canceled.

-- TaskSynchronizer (poor name) - will have two symmetric hashes linking task pointers with node pointers:
   o QHash<ITask *, AdocTreeNode *> --> enables quick lookups from TaskManager signals
   o QHash<AdocTreeNode *, ITask *> --> enables quick lookups from AdocTreeNodes

-- Outstanding items:

   o TaskAdocConnector: Handle the case where the task is destroyed from the TaskManager; it will need to somehow update
     the TransientTaskEntity... [done]
   o Pass TaskManager to InsertBlastReportsCommand (for removing tasks in undo as necessary) [done]
   o TaskManager::remove task functionality (for calling from the undo method of InsertBlastReportsCommand) [done]
   o InsertBlastReportsCommand - accept vector of nodes [done]
   o MultiSeqTableModel needs to respond to the refreshIndex signal of AdocTreeModel [done]
   o BlastReportEntity [mostly done - need to implement the load method]
   o TransientTaskEntityColumnAdapter [done]
   o Make the MainWindow::undo call acceptUndo [done]
   o Transfer name from TransientTask to finalEntity (if relevant) [done]
   o BlastTask
   o Reorganize PsiBlastConfig
   o Flesh out TaskManager interface

-- Example of what should happen when the BLAST button is pressed:

   // Get valid working configuration from the user
   config = ...;
   BlastReportTask *task = new BlastReportTask(config, ...);
   TransientTaskEntity *entity = new TransientTaskEntity(0, "BLAST", "No description", "No notes", task);
   AdocTreeNode *adocTreeNode = new AdocTreeNode(AdocNodeData(entity));

   taskAdocConnector_->add(task, adocTreeNode);
   taskManager_->enqueue(task);
   undoStack_->push(new InsertBlastReportsCommand(adocTreeModel_, adocTreeNode, parent, this);

-- BLAST db formatting stuff: http://www.ncbi.nlm.nih.gov/staff/tao/URLAPI/blastdb.html

[19 Oct 2011]
-- Decided to consolidate the TaskModel to a single model and utilize QSortFilterProxyModels to provide windows into
   the model.

[20 Oct 2011]
-- Designing the blast report entity

[24 Oct 2011]
-- Memory management concern with repositories and reference counting. Originally, the notion behind the repositiory was
   that once a reference count reached zero, it is up to the repo to decide to delete it or keep it cached, yet for
   temporary objects this may pose a problem. For example:

   o A user imports a sequence to a particular location on the data tree (ref count = 1 via the MultiSeqTableModel)
   o Navigates to another folder (ref count = 0)
   o Repo decides to delete object because the ref count is zero
   o User navigates back to the original folder
   o Repo tries to look up object in datasource but it is not found, and thus returns a null pointer

   Observation: objects that have not been persisted should not be automatically removed from the repository. Easy way
                to check: call the IEntity::isNew() method - these have not been persisted.

-- If the following error message appears:

   expected initializer before QtCoreModule or similar

   Check that all classes/structs have been terminated with a semicolon!!

[27 Oct 2011]
-- Finally refactored and reorganized the TreeNode structure. A fairly large task given its prevalence in the codebase.
   Lessons learned along the way:

   o Iterators - http://www.cplusplus.com/reference/std/iterator/
                 http://sourcemaking.com/design_patterns/iterator/cpp/1
                 http://drdobbs.com/database/184404325

   o Curiously Recurring Template Pattern
     http://eli.thegreenplace.net/2011/05/17/the-curiously-recurring-template-pattern-in-c/
     http://www.informit.com/articles/article.aspx?p=31473&seqNum=3

     This was highly useful in the TreeNode class for creating custom tree nodes without having to recode all the
     details of tree management.

   o Template template parameters - http://www.informit.com/articles/article.aspx?p=376878

   o Details on when to use virtual methods: http://www.gotw.ca/publications/mill18.htm

-- Use the slik subversion command line client in windows.

[29 Oct 2011]
-- Steps to use the new subversion repo:

   1) Upgrade to subversion 1.7
   2) Backup (optional) and remove working copy
   3) Add caphuff to list of hosts or note its IP address
   4) Add the following to the .ssh/config file (*nix):

      host caphuff
          Hostname caphuff [or IP]
          Port 32790
          ForwardAgent no
          ForwardX11 no

   5) Navigate to the directory where you want to download a local copy
   6) Check out the latest with the following:

      svn co svn+ssh://caphuff/home/svn/repos/alignshop/trunk AlignShop

[31 Oct 2011]
-- To get SlikSVN working on windows:

   o Download putty / puttygen / plink
   o Run puttygen
     - create a private key
     - Save it
     - Copy public key text to .ssh/authorized_keys
   o Open putty
     - Configure session to target host
     - Be sure to specify auto user name
     - Provide location of the private ssh key created above
     - Save session as SESSION_NAME
   o Install SlikSVN
   o Edit %APPDATA%\Subversion\config
     - Add to the tunnels section:
       ssh = c:/path/to/plink -load SESSION_NAME
   o When checking out code, do not specify the host. For example:

     svn co svn+ssh:///caphuff/home/svn/repos/alignshop

   NOTE: %APPDATA% = User Name\AppData\Roaming

   o To check out from windows via a new project use the following checkout line:

   svn+ssh:///home/svn/repos/alignshop/branches/sptr-branch



[2 Nov 2011]
-- Reference to compile qt on windows using msvc2010:
   http://www.holoborodko.com/pavel/2011/02/01/how-to-compile-qt-4-7-with-visual-studio-2010/

-- Compile NCBI-Blast using MSVC2010:

   When compiling xblast.lib, receive error that cannot convert int to CSeq_id_Info *. The fix:

   src/objects/seq/seq_id_tree.cpp, l 358:

   Change: m_IntMap.insert(TIntMap::value_type(value, 0));
   To:     m_IntMap.insert(TIntMap::value_type(value, static_cast<CSeq_id_Info *>(0)));

[3 Nov 2011]
-- To retrieve sequences from a BLAST database:

   o Use blastdbcmd with the following options:
     - target_only
     - entry_batch - (the dash indicates that we will dump all data to stdin)
   o QProcess - setProcessChannelMode(QProcess::MergedChannels) - to integrate the stdout and stderr. This will
     effectively report one sequence per request and it will be easy to track whether or not a sequence was found.

-- To setup redmine with mod_passenger:

   o emerge passenger
   o Add -D PASSENGER to /etc/conf.d/apache2
   o Setup the vhost:

<VirtualHost *:80>
        ServerName redmine.agilegenomics.com
        DocumentRoot "/var/lib/redmine/public"

        RailsEnv production
        RailsBaseURI /

        <Directory "/var/lib/redmine/public">
                   Options FollowSymLinks
                   AllowOverride All
                   Order allow,deny
                   Allow from all
        </Directory>
</VirtualHost>

[4 Nov 2011]
-- More about the importing of sequences using the blastdbcmd:

   o No parse_seqids: have phr, pin, psq data files
   o Not possible to tell if the taxonomy has been assigned or not from looking at the files on the filesystem

   o It should always be possible to use the ID field from within the blast report as entry input
   o Because the ID field may contain multiple identifiers it is important to parse this successfully first. But... this
     is back to the original problem of what to do with BLAST databases that do not have seq ids parsed? This would
     require the ordinal id. Actually, in these cases, the ID = gnl|BL_ORD_ID|\d+, which works just fine with
     blastdbcmd.

   o Order of tests:
     - gi|\d+
     - gnl|BL_ORD_ID|\d+
     - lcl|\d+

     * If it does not match one of the following, throw an error.

[8 Nov 2011]
-- Turns out the gnl|BL_ORD_ID|\d+ is database volume specific. In other words, if the user database spans 2+ volumes,
   then it is not directly possible to use the BL_ORD_ID values returned in the XML output because the BL_ORD_ID values
   restart at 0 for each volume - argh! For some swine reason, the xml input only contains the blast_ord_ids per volume.

   Workaround: the accession for each blast hit in the above scenario refers to the correct BL_ORD_ID and when used in
   blastdbcmd requests returns the expected sequence. Thus, it is possible to replace the blastxml gnl|BL_ORD_ID|XXX
   id's with gnl|BL_ORD_ID|{accession} and achieve the desired result.

-- C++ note:
   throw by itself can only occur when an exception has already been thrown!

[17 Nov 2011]
-- Successfully migrated to using boost smart pointers. While these are already typically present on linux systems, it
   is not the case with windows. Thus, it is necessary to install the Boost libraries beforehand or AlignShop will fail
   to compile. This is most easily done by utilizing the Boost graphical installer and solely installing the libraries.
   Next update the INCLUDEPATH to point to the boost root directory and recompile.

-- While smart pointers (shared_ptr in particular) alleviate many potential memory issues, care must be taken that
   objects do not survive longer than they should. Thus, in debug mode when a repository is deleted, it checks that all
   members are unique. That is, the repository contains the only outstanding reference.

   To make this happen, it is essential that all involved components release any shared pointers before the repositories
   are closed down, which occurs when the Adoc is closed. Thus, things like the BlastReportModel must release any
   BlastReport reference before closing the Adoc (or delete the blastReportModel before the Adoc is closed). Similarly,
   the data tree should be freed beforehand as well.

-- Psi-Blast once again was not respecting the number of requested hits to retain. Originally, I thought this was
   controlled by the max_target_seqs option; however, it turns out when using the xml outfmt option, only the
   num_alignments option should be used.

-- Outstanding issues:

   o Transient task nodes should not be saved in the entity tree. Need to implement a filter iterator.
   o BLASTN support
   o ClustalMsaBuilder

[18 Nov 2011]
-- To compile typically linux program for windows, it is helpful to use cygwin.

   Cygwin install process:
   o Download the setup.exe file from cygwin
   o Run cygwin and install as normal. By default a minimal set of packages is selected. For development work, select
     these as well:

     Devel/gcc-mingw-core       ** Used these because the regular gcc versions had flaky support (namely, could not find
                                   common functionality like time.h)
     Devel/gcc-mingw-g++
     Devel/make
     Devel/autoconf
     Devel/automake
     Devel/subversion

     It's also helpful to install an editor (e.g. emacs)

   o Let it download and install, adding a desktop icon to start a cygwin shell is also useful.
   o mkdir -p /mnt/c
   o Open it and edit the fstab to have an entry for mounting the C-drive
     c: /mnt/c ntfs binary,user

   o Cygwin provides a POSIX emulation layer by default, which consequently makes it impossible to run cygwin compiled
     programs outside of cygwin without the cygwin DLL. Not very desriable. To sidestep this, use the -mno-cygwin flag
     when compiling:

     CC="gcc -mno-cygwin" CXX="g++ -mno-cygwin" make

   o Example:

     $ tar zxvf clustalw-2.1.tar.gz
     $ cd clustalw-2.1
     $ ./configure
     $ CC="gcc -mno-cygwin" CXX="g++ -mno-cygwin" make

   References:
   http://stackoverflow.com/questions/1981043/running-an-application-compiled-in-cygwin-without-having-cygwin-installed
   http://wiki.videolan.org/Configure

   o To get this to work for Kalign (and I think the above also), it is necessary to set the CC and CXX variables
     before running configure. Actually, I had to edit the makefile after configure was complete and manually update the
     CC variable to use -mno-cygwin.

-- To find a cygwin package that contains a particular file, use the cygcheck -p {file} command
   Reference: http://www.trueblade.com/knowledge/finding-which-cygwin-package-contains-a-particular-file

[23 Nov 2011]
-- QWizard button specifics:

   o To disable the back button: previousPage->setCommitPage(true)
   o To disable the next/finish button: bool isComplete() { return false; }
   o To respond to wizard cancel requests: override the QWizard::reject() method

[9 Dec 2011] :: 45 min convo with Charlie Brown

-- Rate: $430 / hour
-- Need a clear timeline of employment (noting majority when more than 2 companies) and invention
   o Primary affiliation = majority time
-- Worst case: GT + UT + ORNL all want a piece
-- Notion of reduction to practice: cannot file a patent application until it has been reduced to practice. Does not
   necessarily mean an explicit implementation, could also be conceptually reduced to practice. In software, the bar
   is rather low for this. Thus, just having enough mental information in place may be sufficient.

-- Public use and disclosure: have 1 year within this time to file a patent application. Because grants are use public
   funds, the freedom of information act likely nullifies anything included in the grant.

-- If the grant contains the invention details and its submission marks the time of invention, then since that occurrred
   in Jan - Apr 2009, it is probably not necessary to file an invention disclosure; however, it may be worth getting the
   university to sign off on any ownership at this point and thus still useful to get the invention disclosure form
   signed.

   The major push for such a form is patentability. The form provides protection that they will not come after us if we
   get a patent. Of course, if the company grows big, then they may come knocking as well. My take: better to get a free
   and clear now when I'm a no-name.

-- Another issue is the wording. It is almost as though the invention form is implying that UT owns the technology. When
   that is debatable. So... must be cautious in what we seek.

-- Question: is there anything novel or unique about this tool compared to others that was developed since the
   invention? I think this needs to be kept separate from the form <-- check on this again.

-- When filling out the form, the description sounds good, but also provide:

   a) A copy of the grant
   b) Cover letter describing my position and ownership interest and the disposition I would like UT to take concerning
      this technology (they declare that I own it 100% free and clear; e.g. Please check the box that assigns/declare
      all ownership is mine).
      -- Note that this developed separately from my employment with UT.

-- Actions:
   0) Check for old engagement letter and if it has a lower rate; sign the relevant one
   1) Get the name and title of the UT lady
   2) Write cover letter describing our position
   2b) Get Charlie to review it
   3) Attach copy of the grant
   4) Build detailed timeline of employment, time of invention, novel technology development, and any public disclosure

-- Other notes:

   o Packaging of GPL programs (either GPL v2 or v3) with a closed-source application.

     Approach to dealing with these questions: must think of the remedy. In this case, if they came after us and said
     that no, you cannot distribute our program with yours, would simply have to stop distribution and tell user to
     install themselves. It is also possible if this happens to provide a button that would have it automatically
     installed for them. They only thing they can do is possibly make us stop distributing it. There is no real
     possibility of them coming after large chunks of money - the resources available to open-source folks is just not
     there.

[21 Dec 2011]
-- To set the default file name in QFileDialog, use the selectFile method with the desired name.

[10 Jan 2012]
-- Unless DNA sequences are really GC rich,

-- Fully denatured sample, start slowly bringing temperature down, Tm = temp when 50% of the strands are reannealed (in
   PCR context). Melting folks are studying pure physical chemistry. Mol bio folks only want it to work.

-- Other primer notes:

   o Primer search
     - length range of primers does not include any restriction enzyme
     - include any restriction enzyme in the tm calculation
     - include any restriction enzyme when scoring primer pairs

[16 Jan 2012]
-- Wizard notes:

   o To access a value using the field method of a custom control, it is necessary to expose these properties using
     the Q_PROPERTY macro inside the control header class:

     class ThreePrimeInput ...
     {
         Q_OBJECT
         Q_PROPERTY(QString text READ text)

     public:
         ...
     };

-- To sort numerically on a QTableView or the such, it is important to return the values as numbers - not formatted
   QStrings. To accomplish formatting and sorting of double's to a certain precision it is necessary to first round
   them to the relevant precision and then return that value.

-- To install Boost on windows, use boostpro - it will dramatically simplify things!!

   Simply, download the relevant installer (e.g. BoostPro_1.47.0_installer.exe) and run the setup. Uncheck everything
   except the boost headers. Install to dev/boost_1_47 directory and recompile!

   Argh! If only I had documented this the first time round, things would have been much easier.

[17 Jan 2012]
-- Potential AlignShop names:

   Genomics     Comparaitve     Editor      Secondary structure     Suite
   Efficient    Tool            Organizer   BLAST                   Nike
   Fast         Visualization   Protein     Analysis                Results
   Sequence     Integrated      DNA         Workflow                Workbench
   Alignment    Streamline      Primer      Helix                   GenEditor
   Multiple

   Genor        Gentor          Intomics    IGAS
   Intgror      Gestor
   Nestor

   BioHawk
   BioFox
   Dragonfly
   Grasshopper
   Eagle
   Hawk
   Monkey
   Swallow
   Fox
   Biology
   Gendragon
   GenomeFly
   GenFly
   HelixFly


[31 Jan 2012]
-- Macintosh Integration notes:

   o Compilation complains that it cannot find gcc-4.2. Solution - use Clang tool chain - select under the build
     settings
   o Subversion - download from wandisco
   o Must specify the complete absolute path for the build directory; otherwise, attempts to build in the /Applications
     directory
   o Scopes in qmake:
     Linux: only unix defined
     Mac: unix and mac defined
     For unix only: unix:!mac

   o boost on mac, download and update INCLUDEPATH for the mac scope

-- To compile with the CLang compiler, the LoadRequestManager class (AbstractMultiEntityTableModel.h) QHash parameter
   had to be typedef'ed. Go figure.

-- Additionally, to get the sqlite to work, needed to add a special ifdef for the mac arch.

[1 Feb 2012]
-- Not using the NCBI ToolBox, but rather blast+

-- How to build blast+ on mac: http://www.blaststation.com/freestuff/en/howtoBuildBlastMac.html !!

-- The gcc tools come are part of the Xcode package. Turns out that the most recent Xcode (v4.2) causes some issues
   while compiling blast+. Specifically it crashes while attempting to compile writedb. Interestingly, it compiles fine
   in debug mode, but not release mode. I frustrated tried numerous different configurations - all to no avail.

   Finally, what worked was downloading a previous version of Xcode (v3.2.1). To have multiple versions of Xcode
   installed, just use a different directory. The most recent is installed in /Developer and the older 3.2.1 version I
   installed in /Developer-3.2.1

   Reference: http://iphonedevelopertips.com/xcode/download-and-install-older-versions-of-xcode-xcode-previous-releases.html

   xcode-select facilitates switching between paths.

-- The equivalent of LD_LIBRARY_PATH on mac is DYLD_LIBRARY_PATH

-- To view the run-time library dependences on mac, use the otool command:

   otool -L blastx

-- To update the dependencies, use the install_name_tool command:

   install_name_tool -change old_library_path new_library_path {executable}

   o Can use @executable_path to reference a path relative to the path containing the executable.

[6 February 2012]
-- Apparent the current index changes independently of the selection. Means that both signals must be connected to as
   needed.

   Also, it appears that the selection change occurs first, and then the current index change signal. Thus, it is not
   possible to retrieve the correct current index from a selection changed slot.

[7 February 2012]
-- QFileCopier links:

   http://doc.qt.nokia.com/solutions/4/qtcopydialog/qtfilecopier.html
   https://gitorious.org/qfilecopier/qfilecopier/

-- Found 3 relatively reasonable commercial icon packs to give AlignShop a face lift:

   http://www.axialis.com/stock-icons/
   http://www.seanau.com/
   http://www.iconexperience.com/ (V-collection)

   o Decided to purchase the Seanau icon set for $169.
   o Liked the Axialis set, but it was licensed per user, which was more to think about than I cared for.

-- Now that releases are imminent, need to think through how to deal with versioning.

   Reference: http://en.wikipedia.org/wiki/Software_versioning (tons useful information on what is currently done)

   Scheme that I have chosen to follow: {major}.{minor}-{build type}
   {build type} includes: dev => developmental work not ready for external testing
                          a => alpha release
                          b => beta release
                          rc => release candidate
                          r => commercial release

   All build types may be appended with a sequence number indicating its current version. The first official test
   release will be: 0.5-a1

   Each release will be tagged in the subversion repository. Additionally, the svn revision number should be included
   in the about box of each release as well.

-- Decided to utilize shared libraries for the BLAST+ executables since otherwise, they are exorbitantly large.

-- To properly set the rpath while building the BLAST+ executable, use the following configure command:

   (Linux)
   ./configure --without-debug --with-dll --with-mt --with-64 --with-lfs --with-strip --without-pcre --with-configure-dialog --with-flat-makefile --with-runpath="'\$\$ORIGIN/lib'"


   References on RPATH and its nuances:
   http://itee.uq.edu.au/~daniel/using_origin/

-- Other notes on building the BLAST+ packages:

   o For some reason when additional flags are specified on the command line it is not possible to start the configure
     dialog (which is necessary to specify the projects to be built). Therefore, the first run should be simply the
     following:

     ./configure --without-debug --with-dll --with-mt --with-64 --with-configure-dialog

     -- After this has completed, the configure dialog should appear. Hit next and then select the relevant projects,
        optionally save, and then click finish.

     -- Now, re-run the configure command with all the desired options (see above)
     -- cd into the relevant build directory and make -j9 -f Makefile.flat
     -- To clean the build, it is necessary to edit the Makefile.flat file and set MTARGET = clean, and then re-run
        the make command (make -f Makefile.flat). Be sure to remove the clean flag once ready to rebuild.

[10 February 2012]
-- Finished the version tooling automation and incorporation into AlignShop:

   o Reference:
     http://qtcreator.blogspot.com/2009/10/generating-automatic-version-numbers.html
     http://qtcreator.blogspot.com/2010/05/code-to-generate-version-number-header.html

[13 February 2012]
-- When specifying xcopy paths in win32, it is essential to use backslashes as forward slashes are not
   interpreted properly.

[14 February 2012]
-- Windows deployment notes:

   Building with MSVC 2010, executables will require the following windows-specific DLLs:

   msvcr100.dll
   msvcp100.dll

   These were found in C:\Windows\SysWOW64.

[18 February 2012]
-- Basic approach to license keys:

   Construct a secret key that is somehow comprised from various parts that are distributed throughout the program
   Algorithm for producing valid keys consists of hashing the username with the secret key and comparing to the license
      key supplied to the user.

   Thus, whenever a user purchases a copy, he will be given a valid license key which is tied to his name that he gives
   us at time of purchase.

   Method for validating the license:

   user;
   license-key;
   Each time the program is run:
     if QSettings contains the user and license-key
       update user and license-key
     while (invalid license-key and user combination and !canceled)
       display registration dialog
       get user and license-key
     write user and license-key to QSettings and save

-- This approach needs to be slightly modified to allow for time-expired programs (e.g. betas)

   user;
   license-key;
   Each time the program is run:
     if QSettings contains the user and license-key
       update user and license-key
     while (invalid license-key and user combination and !canceled)
       display registration dialog
       get user and license-key
     current_time = get time from clock
     file_timestamp = get timestamp AlignShop executable was created locally
     stored_timestamp
     if (!stored_timestamp)
       stored_timestamp = file_timestamp
     timestamp = max(stored_stamp, file_timestamp)
     if (current_time < timestamp || current_time - timestamp > {trial period})
       display expiration message
       exit
     write stored_timestamp to QSettings

-- Or as an alternative to getting the timestamp from the file / file created date, simply make it part of the license
   key. For instance, encode the timestamp as a series of numbers that prefix the actual license key data.

-- To discourage re-downloading beta after trial has expired, require email address for the beta and store this on
   the server. Then whenever user requests beta, can simply check if this email has been used before.

-- A potentially useful option is to randomly (or whenever there is an internet connection), phone home with the
   network interface's MAC address and license information. This could then be recorded and analyzed for information
   on usage and potential piracy.

     QNetworkInterface: http://developer.qt.nokia.com/doc/qt-4.8/qnetworkinterface.html#hardwareAddress
     Easy mechanism for getting the mac address.

-- References:

   Good overview and pseudo-demonstration of how to implement license keys and registration:
   http://www.mere-mortal-software.com/blog/details.php?d=2008-05-07

   http://stackoverflow.com/questions/1871212/implementing-expiration-dates-in-an-application

   Hints on how to make a reasonable license key
   http://www.codinghorror.com/blog/2007/12/software-registration-keys.html




[21 Feb 2012]
-- In many visual cases, positioning widgets depends upon whether a scrollbar is visible or not; however, for the
   scrollbar visiblity to be updated, it is necessary to finish processing events. Unfortunately, many widgets process
   must respond *before* this happens. Depending on the scroll bar policy, it is possible to simply look at the min/max
   values of the scrollbar as an alternative gauge. This is done in the MsaWindow files (and possibly others) for
   setting the bottom contents margin in response to font/zoom render changes.

   TODO: make a consolidated code base for properly handling these conditions.

-- Merging the sptr-branch back into trunk

   $ cd dev/qt/
   $ mv AlignShop AlignShop-old
   $ svn co svn+ssh://caphuff/home/svn/repos/alignshop/trunk AlignShop
   $ cd sptr-branch
   $ svn log --stop-on-copy
   [Note the last revision displayed, in this case it was r591]
   $ cd ../AlignShop
   $ svn update [just in case]
   $ svn info
   [Note the most current revision, in this case 696]
   $ svn merge -r591:696 svn+ssh://caphuff/home/svn/repos/alignshop/branches/sptr-branch
   [Update all the build settings and recompile to ensure that it works]
   $ svn commit -m "Merged AlignShop sptr-branch [591]:[696] into trunk"
   $ rm -rf ../sptr-branch
   [remove the sptr-branch directory]

   References:
   o http://www.sepcot.com/blog/2007/04/SVN-Merge-Branch-Trunk
   o https://wiki.openmrs.org/display/docs/Subversion+Branching+and+Merging+Techniques [closing a branch]

-- To tag a revision:

   svn copy svn+ssh://caphuff/home/svn/repos/alignshop/trunk svn+ssh://caphuff/home/svn/repos/alignshop/tags/0.5a2 -m "Release 0.5a2"

[29 Feb 2012]
-- The way that Qt and Msa handle moving of rows is significantly different. Common to both is the source range - it is
   the meaning of the target dest row that varies. In my MSA implementation, the dest row indicates the row where the
   first element of the source range should be placed. Thus, it is make perfect sense to reference a location inside the
   source range. For example (* = selected):

   1
   2 *
   3 * <--- X
   4 *
   5

   source range = 2..4, X = dest row. This is fully valid in the MSA case because it is saying that 2 .. 4 should begin
   at the third index. Consequently, the max dest row is N - range.length() + 1, where N = number of sequences.

   In the Qt model view, dest row indicates the location where the rows should be inserted *before*. A constraint on
   their part is that the drop row cannot be anywhere from range.begin to range.end + 1. When models call
   beginMoveRows(), it is vital that the drop row uses Qt's system otherwise a strange corrupted double error will
   happen that is not immediately obvious why.

   See MsaSubseqTableModel for an example of how these cases are handled.

-- Tablewidget example:

    ui_->tableWidget_->clear();
    ui_->tableWidget_->setColumnCount(eNumberOfColumns);
    ui_->tableWidget_->setRowCount(bioSymbolGroup.count());
    ui_->tableWidget_->setHorizontalHeaderLabels(horizontalHeaderLabels());
    ui_->tableWidget_->horizontalHeader()->setStretchLastSection(true);
    ui_->tableWidget_->horizontalHeader()->setResizeMode(eAminoAcidsColumn, QHeaderView::Stretch);

    const QHash<char, BioSymbol> bioSymbols = bioSymbolGroup.bioSymbols();
    QVector<char> symbols = bioSymbolGroup.symbolsInSerialOrder();
    ASSERT(symbols.size() == bioSymbols.size());
    for (int i=0; i< symbols.size(); ++i)
    {
        char symbol = symbols.at(i);
        const BioSymbol bioSymbol = bioSymbols.value(symbol);

        QTableWidgetItem *newItem = new QTableWidgetItem(bioSymbol.label());
        ui_->tableWidget_->setItem(i, eLabelColumn, newItem);

        newItem = new QTableWidgetItem(QChar(symbol));
        ui_->tableWidget_->setItem(i, eSymbolColumn, newItem);

        newItem = new QTableWidgetItem(QString(bioSymbol.characters()));
        ui_->tableWidget_->setItem(i, eAminoAcidsColumn, newItem);

        ui_->tableWidget_->setCellWidget(i, eDeleteButtonColumn, new QPushButton("Delete"));
    }
